1
00:00:00,333 --> 00:00:06,333
[Music]

2
00:00:17,483 --> 00:00:18,466
>> Welcome back, folks.

3
00:00:19,183 --> 00:00:22,466
Thanks for joining Tobias and myself as we walk you through Querying

4
00:00:22,483 --> 00:00:27,166
SQL Server 2012 and trying to show you some cool little tips

5
00:00:27,483 --> 00:00:29,466
and tricks for getting the most out of your databases in SQL

6
00:00:29,483 --> 00:00:33,433
Server 2012. We're going to move into another module here, so

7
00:00:33,483 --> 00:00:36,466
we're going to be talking about aggregating or grouping and aggregating data.

8
00:00:37,483 --> 00:00:39,466
We've gone through some... pretty much some fundamental, some

9
00:00:39,483 --> 00:00:43,466
basic information about SQL Server, we're talking kind of, again,

10
00:00:43,233 --> 00:00:45,433
level the playing field. We've introduced some of the advanced

11
00:00:45,483 --> 00:00:48,466
select statements. We talked about SQL Server data types in the

12
00:00:48,483 --> 00:00:50,466
previous model and the importance of those as you're creating

13
00:00:50,483 --> 00:00:53,466
your objects and understanding how they're going to be used.

14
00:00:53,483 --> 00:00:57,466
What we're going to do now is looking at aggregate functions.

15
00:00:57,483 --> 00:01:00,466
I call them aggravating because sometimes they can be that way.

16
00:01:00,483 --> 00:01:04,466
Or and as well as grouping by or group by and having clauses.

17
00:01:04,483 --> 00:01:08,466
We'll talk about subqueries, both all the self-contained, correlated

18
00:01:08,483 --> 00:01:13,466
and exists. And we'll take a look at a view, creating a view.

19
00:01:13,483 --> 00:01:15,466
And we'll look at some of these tables. We've had some questions

20
00:01:15,483 --> 00:01:19,350
on inline tables and derived tables. We'll talk about that in

21
00:01:19,433 --> 00:01:22,466
this section as well. So we're going to head right on into that

22
00:01:22,483 --> 00:01:27,466
and have a conversation to begin with on aggregate functions.

23
00:01:27,483 --> 00:01:30,466
And there's three categories of these functions. There's the

24
00:01:30,483 --> 00:01:33,466
common ones that we'll see like the sum and the min, the max,

25
00:01:33,483 --> 00:01:36,466
the average account. We have some of these statistical ones.

26
00:01:36,483 --> 00:01:39,433
And for Friday the 13th I'm glad I was able to say that.

27
00:01:40,483 --> 00:01:43,466
Standard deviation, for instance, and we have the var, the var

28
00:01:43,483 --> 00:01:47,233
P, and we have some other ones like grouping and grouping ID

29
00:01:47,316 --> 00:01:51,466
that are available for us as well. So we have these categories

30
00:01:51,483 --> 00:01:54,316
of aggregate functions that we have available to us.

31
00:01:55,483 --> 00:01:59,400
If we begin working with aggregate functions, they return a scalar

32
00:01:59,483 --> 00:02:03,316
value with no column name. They're going to ignore nulls most

33
00:02:03,400 --> 00:02:06,466
of the time with the exception of the count. They can be used

34
00:02:06,483 --> 00:02:10,466
in the select statement, the having, and the order by clauses.

35
00:02:10,483 --> 00:02:12,466
They're frequently used with the group by clause. And we have

36
00:02:12,483 --> 00:02:18,466
an example of a select count, distinct sales order ID as unique

37
00:02:18,483 --> 00:02:22,466
orders, and we have average unit price as a column name.

38
00:02:22,483 --> 00:02:26,466
Minute... or minimum order quantity. And we have maximum line

39
00:02:26,483 --> 00:02:29,466
total for a particular line item. And we're retrieving this

40
00:02:29,483 --> 00:02:32,466
information from the sales order detail table. And as you can

41
00:02:32,483 --> 00:02:35,466
see an example on the results are in the bottom here where we

42
00:02:35,216 --> 00:02:40,466
have 31,465 unique orders. The average unit price is $465.

43
00:02:40,483 --> 00:02:43,466
We're getting that from the average there. The minimum order

44
00:02:43,483 --> 00:02:47,466
quantity is 1. I would hope there not be a detailed line order

45
00:02:47,483 --> 00:02:50,466
detail for 0 order quantity, so I was glad to see that as 1.

46
00:02:51,483 --> 00:02:53,466
And then we did a max line total is 27,893.619000.

47
00:02:57,483 --> 00:03:02,466
So we did get a retrievalable of content from... and this contains

48
00:03:02,483 --> 00:03:06,466
four aggregate functions within one statement which makes it

49
00:03:06,483 --> 00:03:11,383
nice so we can summarize that content and kind of give us a display

50
00:03:11,483 --> 00:03:15,466
instead of looking at 31,000 records plus to determine what's

51
00:03:15,483 --> 00:03:19,466
going on with the number of items in those... in that details table.

52
00:03:20,483 --> 00:03:22,466
The distinct clause, we talked about that. We've introduced

53
00:03:22,483 --> 00:03:26,466
that a couple times with aggregate functions, provide you that

54
00:03:26,483 --> 00:03:27,466
summary of information.

55
00:03:28,316 --> 00:03:32,466
It aggregates, but during the aggregation it eliminates those

56
00:03:32,483 --> 00:03:37,466
duplicate values, not rows, but it eliminates the information

57
00:03:37,233 --> 00:03:40,466
that would be normally provided. And we have an example here again.

58
00:03:40,483 --> 00:03:44,466
We're doing a count on distinct customer ID and we're using that

59
00:03:44,483 --> 00:03:47,466
information and then returning information about the salesperson

60
00:03:47,483 --> 00:03:51,466
ID, the order year, the all customers, and any unique customers.

61
00:03:51,483 --> 00:03:55,466
So we're trying to find out per salesperson how many customers

62
00:03:55,483 --> 00:03:59,466
they have as a whole and per year how many unique customers they had.

63
00:03:59,483 --> 00:04:04,466
So this is what this... the query will do for you with this aggregate

64
00:04:04,483 --> 00:04:06,466
function used in the distinct clause.

65
00:04:06,483 --> 00:04:10,366
>> Okay. I'd like to just throw something here to kind of disambiguate

66
00:04:10,450 --> 00:04:14,466
a little bit between the various things you can use. And again

67
00:04:14,483 --> 00:04:15,466
I apologize for

68
00:04:16,483 --> 00:04:17,466
what my...

69
00:04:17,483 --> 00:04:19,466
>> Your monitor freaking out on you?

70
00:04:19,483 --> 00:04:20,366
>> Yeah, yeah.

71
00:04:20,450 --> 00:04:21,466
>> It's like come back.

72
00:04:21,483 --> 00:04:23,433
>> I logged out and then it was all fine.

73
00:04:23,450 --> 00:04:23,466
>> Okay.

74
00:04:23,483 --> 00:04:28,266
>> So just looking at this distinct and aggregates and group by,

75
00:04:28,350 --> 00:04:34,466
so let's say I just get all orders.

76
00:04:35,433 --> 00:04:43,466
Right? There we go. Now I want to get...

77
00:04:44,483 --> 00:04:49,466
let's say what I want to get is I want to get really maximum

78
00:04:49,483 --> 00:04:52,466
of one order per customer. So I'm interested in this distinct

79
00:04:52,483 --> 00:04:56,466
thing per customer. So I try and just calculate it. So I'll

80
00:04:56,483 --> 00:04:58,466
just do count, distinct

81
00:04:59,483 --> 00:05:02,466
customer ID. So now we'll know, okay, this is how many customers

82
00:05:02,483 --> 00:05:08,216
are referenced in this table. Okay. So 19,000 something.

83
00:05:09,483 --> 00:05:14,166
What if I now want to have 19,000 rows returned but I only...

84
00:05:14,250 --> 00:05:16,466
but I want the... so one order per customer.

85
00:05:16,483 --> 00:05:17,466
>> Right.

86
00:05:17,483 --> 00:05:20,466
>> But I also want other information. So I can try and do group

87
00:05:20,483 --> 00:05:25,466
by and let's say, okay, give me customer... give me everything

88
00:05:25,483 --> 00:05:27,466
and I want to group this by customer ID.

89
00:05:29,166 --> 00:05:31,466
Well, this doesn't... doesn't make a lot of sense, right?

90
00:05:31,483 --> 00:05:36,0
Because now you're saying calculate some aggregate for every customer.

91
00:05:36,483 --> 00:05:40,466
So I'm expecting to get one row back per customer but we're returning details.

92
00:05:40,483 --> 00:05:43,466
Right? We're not using aggregates. So I could then say, okay,

93
00:05:43,483 --> 00:05:45,466
give me just customer ID back.

94
00:05:47,483 --> 00:05:50,466
And now I'll get just a customer ID and I can say use an aggregate

95
00:05:50,483 --> 00:05:53,466
like com star or something to get the number of rows. But I

96
00:05:53,483 --> 00:05:55,466
want the details in this case.

97
00:05:55,483 --> 00:05:59,466
If I try and use distinct over this, then obviously do distinct

98
00:06:00,483 --> 00:06:01,466
over the entire row.

99
00:06:01,483 --> 00:06:04,466
What I can do is use this row number thing that's very interesting

100
00:06:04,483 --> 00:06:09,466
for this problem. So, again, what I'm after is give me one order

101
00:06:09,483 --> 00:06:13,166
per customer back. So basically the first or last order for every customer.

102
00:06:13,250 --> 00:06:14,466
But I want all of the order details.

103
00:06:15,483 --> 00:06:21,333
So I'll say select star from sales order header, and I'll say,

104
00:06:21,483 --> 00:06:23,466
okay, please calculate now the row number

105
00:06:26,483 --> 00:06:28,466
over partition by

106
00:06:30,250 --> 00:06:34,316
customer ID. So basically start counting again when it's a new

107
00:06:34,400 --> 00:06:39,466
customer ID. And order by... let's say I want the newest orders,

108
00:06:39,483 --> 00:06:42,466
so I want the latest order for the customer...

109
00:06:42,183 --> 00:06:42,466
>> Right....

110
00:06:42,483 --> 00:06:44,466
>> as row number.

111
00:06:44,483 --> 00:06:50,466
Okay? So this would just execute and calculate the row numbers

112
00:06:50,483 --> 00:06:55,466
for me. Now, what if I just want to have now the first for every

113
00:06:55,483 --> 00:07:00,466
order, you would say something like, well, give me where because

114
00:07:00,483 --> 00:07:04,466
I know I can't say where RN because that's not defined yet.

115
00:07:04,483 --> 00:07:07,466
Right? So I'll say, okay, where row number blah is equal to 1,

116
00:07:09,166 --> 00:07:11,466
well, get me an error back.

117
00:07:11,483 --> 00:07:12,466
>> Yeah.

118
00:07:12,483 --> 00:07:15,183
>> Why? Well, because row number in all of these ranking functions

119
00:07:15,266 --> 00:07:18,466
and aggregate... or, sorry, all of these ranking functions, they

120
00:07:18,483 --> 00:07:23,466
are calculated at select time. Right? So in the workloads, we

121
00:07:23,483 --> 00:07:27,250
have no idea what this row number means because obviously if

122
00:07:27,333 --> 00:07:29,466
I change the where clause and if I say where...

123
00:07:30,483 --> 00:07:33,400
oohh. Fat fingers.

124
00:07:33,483 --> 00:07:34,466
>> Felt that one.

125
00:07:34,483 --> 00:07:40,466
>> If I now say saves order ID is less than a thousand, that would

126
00:07:40,483 --> 00:07:42,466
be part of the query and now the row numbers change, right?

127
00:07:43,483 --> 00:07:46,466
They're based on this number. So what I can do instead is I can

128
00:07:46,483 --> 00:07:50,466
say select start from this set and

129
00:07:52,483 --> 00:07:58,466
now RN exists, right? So now I can say where RN is equal to 1.

130
00:07:58,483 --> 00:08:02,466
So what does this mean? Well, it means get me all of the orders,

131
00:08:02,483 --> 00:08:07,466
calculate the row number for each order per customer, right,

132
00:08:07,483 --> 00:08:10,466
and then give me only the first. So this means give me only

133
00:08:11,0 --> 00:08:13,466
the first order for every customer.

134
00:08:16,483 --> 00:08:18,466
And now I should get this number we can see down here in the

135
00:08:18,483 --> 00:08:21,466
lower right-hand corner, 19,119 rows back.

136
00:08:21,483 --> 00:08:22,466
>> Right.

137
00:08:22,483 --> 00:08:25,466
>> So that's an interesting thing from this.

138
00:08:26,483 --> 00:08:31,466
One is using window functions, row numbers in this case as well

139
00:08:31,483 --> 00:08:34,466
as what does this thing mean and what can you accomplish.

140
00:08:34,483 --> 00:08:37,383
So it very much depends on what you're after, if you want to

141
00:08:37,466 --> 00:08:41,416
use distinct, count distinction, or something such as row number

142
00:08:41,483 --> 00:08:45,466
to grab the latest orders. Let's say I wanted to get all orders

143
00:08:45,483 --> 00:08:48,466
that are made in the same day. Now, row number... if they're

144
00:08:48,483 --> 00:08:51,466
made in the same day, they'll get different row numbers, right,

145
00:08:51,216 --> 00:08:54,466
1 and then 2, 3, 4, even if they have the same value and randomly

146
00:08:55,483 --> 00:08:59,466
in the order we find them. But if I would say rank, now I would

147
00:08:59,183 --> 00:09:03,466
get multiple orders... rows because I'll get for every...

148
00:09:03,483 --> 00:09:06,466
all of the orders that have the same order date they will come

149
00:09:06,483 --> 00:09:10,466
back with the same rank. So rank 1 can now be multiple orders.

150
00:09:10,483 --> 00:09:13,466
And in this case... let's see if there's this case. Yeah.

151
00:09:13,483 --> 00:09:15,433
So now I got a few of them are on the same day.

152
00:09:15,450 --> 00:09:15,466
>> Yeah.

153
00:09:16,483 --> 00:09:18,466
>> So 19,127 rows back.

154
00:09:19,483 --> 00:09:20,466
>> Very cool.

155
00:09:22,483 --> 00:09:25,466
All right. So we get the group by and having clause that we're

156
00:09:25,483 --> 00:09:28,466
going to be working with. And this is going to be kind of...

157
00:09:28,483 --> 00:09:31,466
again, we're working with the aggregate functions and ways for

158
00:09:31,483 --> 00:09:35,216
us to create summary data and get that summary data. So we're

159
00:09:35,300 --> 00:09:39,466
going to continue on talking about the group by and the having.

160
00:09:39,483 --> 00:09:42,333
Having, select, and order by must... they must return a single

161
00:09:42,416 --> 00:09:45,466
value per group. All columns in this select, having, order by

162
00:09:45,483 --> 00:09:47,466
have to appear in the group by clause. So you have to be aware

163
00:09:47,483 --> 00:09:53,466
of that. If you're going to use a column in the group by clause,

164
00:09:54,483 --> 00:09:55,466
it's got... or in the... yeah. If you're going to use a column

165
00:09:55,483 --> 00:09:57,466
in the group by clause, it has to appear in the select, having,

166
00:09:57,483 --> 00:09:58,466
or order by.

167
00:09:59,483 --> 00:10:03,266
So it has to have appeared up there already. With the logical

168
00:10:03,350 --> 00:10:04,466
order, we've gone through this already, we've seen this a couple

169
00:10:05,483 --> 00:10:10,466
times on the how the statement is actually processed, the from,

170
00:10:10,483 --> 00:10:13,466
then the where, the group by, the having, back up to the select

171
00:10:13,483 --> 00:10:16,216
and then order by being last. It's very, very important for you

172
00:10:16,300 --> 00:10:19,466
to understand that. If you're using the group by, all the subsequent

173
00:10:19,483 --> 00:10:22,466
phases operate on that group, not the source row. So it's going

174
00:10:22,483 --> 00:10:26,300
to work on the group information. And that's why that order

175
00:10:26,383 --> 00:10:29,466
is important to understand here. This one here is actually just

176
00:10:29,483 --> 00:10:34,466
getting a count. It's going to display it as a count as the header

177
00:10:34,483 --> 00:10:37,466
for it. And we're going to group by customer ID. So we're trying

178
00:10:37,483 --> 00:10:40,466
to see how many customers that we have, we're going to group

179
00:10:40,483 --> 00:10:44,466
by customer ID. And then the second statement here, the aggregate

180
00:10:44,483 --> 00:10:47,466
function is going to refer to any columns, not just those in

181
00:10:47,483 --> 00:10:50,466
the group by clause. So we're going to select product ID, max

182
00:10:50,483 --> 00:10:55,266
order quantity as the largest order. So when we run this, we're

183
00:10:55,350 --> 00:10:58,466
going to group it by product ID. So for each product ID we're

184
00:10:58,483 --> 00:11:02,316
going to see the maximum number of items ordered per product.

185
00:11:02,400 --> 00:11:06,366
So this allows us to use that max aggregate function to be able

186
00:11:06,450 --> 00:11:08,433
to return that content to us.

187
00:11:09,333 --> 00:11:13,450
The having clause provides a search condition that every group

188
00:11:13,483 --> 00:11:17,466
in the group by clause must meet. And this is processed after

189
00:11:17,483 --> 00:11:20,466
the group by. So what we're going to do is we're going to select

190
00:11:20,483 --> 00:11:24,466
customer ID and we're going to do a count as count orders from

191
00:11:24,483 --> 00:11:28,466
the sales order header table. We're going to group by customer ID.

192
00:11:28,483 --> 00:11:30,466
And then we're going to say, oh, all those that are group by

193
00:11:30,483 --> 00:11:33,466
customer ID, once that group is created for each customer ID,

194
00:11:34,483 --> 00:11:37,466
having a count greater than 10, so if we have less than 10 we

195
00:11:37,483 --> 00:11:40,466
don't want to really see much about that customer, we want to

196
00:11:40,483 --> 00:11:44,466
see only those items that are returned to us, those rows returned

197
00:11:44,200 --> 00:11:48,466
to us in those groups, that are greater than 10. So we'll do

198
00:11:48,483 --> 00:11:51,466
a count on those customer IDs that are returned to us and then

199
00:11:51,483 --> 00:11:54,466
we'll return the result set with those items that have more than

200
00:11:54,483 --> 00:12:00,466
10 in that count return... the count orders field to be more

201
00:12:00,483 --> 00:12:01,466
specific here.

202
00:12:02,483 --> 00:12:05,466
If I want to compare... so we talked... the having and the where

203
00:12:05,483 --> 00:12:08,466
are similar, but what's... I want to compare the two. The where

204
00:12:08,483 --> 00:12:13,466
filters rows before the groups are created. The having filters

205
00:12:13,483 --> 00:12:16,466
are rows which controls how the groups are going to be passed

206
00:12:16,483 --> 00:12:20,466
to the next logical phase. So if we look at this, we're going

207
00:12:20,216 --> 00:12:23,466
to use a count expression in the having clause. And this is

208
00:12:23,483 --> 00:12:28,466
going to be useful to really provide a solution for common business problems.

209
00:12:28,483 --> 00:12:31,466
Because this is going to show only customers that have placed

210
00:12:31,483 --> 00:12:34,433
more than one order. So in this case here we're doing a select

211
00:12:34,483 --> 00:12:37,466
customer ID, we're going to do a count on that from the sales

212
00:12:37,483 --> 00:12:40,466
customer as customer. And then we're going to join that table

213
00:12:41,483 --> 00:12:44,383
and we're going to join that table to the sales order header.

214
00:12:44,483 --> 00:12:48,466
Then we're going to give it a table name, an alias. And then

215
00:12:48,483 --> 00:12:50,466
we're going to group by customer ID, but then, again, we want

216
00:12:50,483 --> 00:12:54,466
to only see the content where a customer has placed. We're going

217
00:12:54,483 --> 00:12:57,466
to see content for multiple columns, but we're going to see only

218
00:12:57,483 --> 00:13:02,466
the rows returned to us where a customer has more than one order

219
00:13:02,483 --> 00:13:07,466
that's been placed. So that's going to give us a situation to

220
00:13:07,216 --> 00:13:11,466
find who our repeat customers are. We could even take it up

221
00:13:11,483 --> 00:13:14,466
a notch and say I happen to have an account with more than equal

222
00:13:15,333 --> 00:13:18,466
to 10 customers. So again we're trying to see maybe at this point

223
00:13:18,483 --> 00:13:22,466
who our more popular customers are, our busier customers are,

224
00:13:22,483 --> 00:13:25,466
and we'll get that information returned to us by taking advantage

225
00:13:25,483 --> 00:13:27,466
of some of these statements that we're showing here.

226
00:13:29,483 --> 00:13:32,466
So the group by and having clause, is there another... we kind

227
00:13:32,483 --> 00:13:35,466
of just did that one. Is there another demo on the group by and

228
00:13:35,483 --> 00:13:39,200
having we want to take a peek at? That's... I mean, the last

229
00:13:39,283 --> 00:13:40,466
one was pretty cool.

230
00:13:41,166 --> 00:13:43,466
If there's anything specific that you wanted to show us. If not,

231
00:13:43,483 --> 00:13:44,466
we'll just move on.

232
00:13:45,483 --> 00:13:46,466
>> No, I think we're fine.

233
00:13:46,483 --> 00:13:49,183
>> Okay. We're good. All right. Let's talk subquery.

234
00:13:49,266 --> 00:13:52,383
Subqueries could often be a little bit confusing because you're

235
00:13:52,466 --> 00:13:55,333
looking at the query within a query. So with the subqueries

236
00:13:55,416 --> 00:13:58,333
we have to be careful and aware of how they work, and there's

237
00:13:58,483 --> 00:14:01,466
a few different flavors of subqueries that we have associated

238
00:14:01,483 --> 00:14:05,466
with this. So the really nasty queries, so as I mentioned queries

239
00:14:05,200 --> 00:14:09,466
within queries, the results from the nested query are passed

240
00:14:10,483 --> 00:14:13,466
to the outer query. So the inner query acts like an expression

241
00:14:14,466 --> 00:14:17,216
that's going to be returned and used by the outer query.

242
00:14:17,300 --> 00:14:21,466
The subqueries can be self-contained or correlated where self-contained

243
00:14:21,483 --> 00:14:25,466
has no dependency on the out query, outer query. The correlated

244
00:14:25,483 --> 00:14:28,466
subqueries depend on the values from the outer queries.

245
00:14:29,266 --> 00:14:34,466
Subqueries can be either scale or multi... multi-valued or table valued.

246
00:14:34,483 --> 00:14:37,266
So we'll take a look at a scalar subquery here. We're going

247
00:14:37,350 --> 00:14:41,466
to do a select order ID, product ID, unit price, order quantity.

248
00:14:41,483 --> 00:14:43,466
From, the orders detail.

249
00:14:43,483 --> 00:14:47,466
Where, the sales order ID equal. Now we're going to use the

250
00:14:47,483 --> 00:14:50,466
subquery select max sales order ID. And we'll return that in

251
00:14:51,483 --> 00:14:54,466
the column called last order. And we're going to get this information

252
00:14:54,483 --> 00:14:58,333
from the sales order header. So what this is going to do, it's

253
00:14:58,416 --> 00:15:02,466
going to query the sales order header, it's going to look for

254
00:15:02,483 --> 00:15:07,333
the max... aggregate function max for a sales order ID. And it's

255
00:15:07,483 --> 00:15:09,466
going to return that as the last order.

256
00:15:10,250 --> 00:15:13,266
And we're going to go see what information on the last order

257
00:15:13,350 --> 00:15:14,466
that was just processed.

258
00:15:15,483 --> 00:15:17,466
And as you can see from... so additional information, if the

259
00:15:17,483 --> 00:15:20,466
interquery returns an empty set, the results can be converted

260
00:15:20,483 --> 00:15:24,466
to null. And the construction of the outer query determines whether

261
00:15:24,183 --> 00:15:28,466
the inner query is going to return that single value. So we

262
00:15:28,483 --> 00:15:31,466
actually have that with sales order ID, product ID, unit price

263
00:15:31,483 --> 00:15:35,466
and order quantity. Where, sales order ID equal. And then we

264
00:15:35,483 --> 00:15:38,383
have the subquery which is going to return and determine what

265
00:15:38,466 --> 00:15:42,466
that sales order ID is so it can process that order ID.

266
00:15:44,483 --> 00:15:47,466
Now, with multi-valued subqueries... this one's a little off

267
00:15:47,483 --> 00:15:51,466
keel here... the multi-valued subquery returns multiple values

268
00:15:51,183 --> 00:15:53,466
as a single column set. So what we're going to do is we're going

269
00:15:53,483 --> 00:15:57,383
to use the in clause here. We're going to go and query the sales

270
00:15:57,466 --> 00:15:58,466
order header.

271
00:15:58,483 --> 00:16:02,466
We're customer ID in. Well, in what? Well, we're going to perform

272
00:16:02,483 --> 00:16:06,283
another select statement. Select customer ID from sales.customer

273
00:16:06,416 --> 00:16:10,466
where territory ID equal 10. So now we're going to return content

274
00:16:10,483 --> 00:16:15,466
or the outer query will be performed based on the idea of what

275
00:16:15,483 --> 00:16:19,466
customer ID or territory ID equal 10. So it's going to return

276
00:16:20,0 --> 00:16:26,316
that content for us or perform that query for us based on that subquery.

277
00:16:28,483 --> 00:16:31,466
The keyword exist also could be used or not exist as you can

278
00:16:31,483 --> 00:16:35,466
see here. This is select customer ID and person ID. From, the

279
00:16:35,483 --> 00:16:39,466
sales customer. And we're going to rename that as cust.

280
00:16:40,483 --> 00:16:41,400
Where, exist.

281
00:16:42,483 --> 00:16:44,200
What exists? Well, we're going to do a select asterisk, so we

282
00:16:44,283 --> 00:16:46,466
can't use column names when we're using the exist. We have to

283
00:16:46,483 --> 00:16:54,466
use the actual... the asterisk or return all columns. From, sales.salesorderheader

284
00:16:54,483 --> 00:17:01,233
as ord, so for order. Where, cust.customer ID equal order.customer ID.

285
00:17:01,316 --> 00:17:04,466
So we're going to do a match on customer ID from the two tables

286
00:17:05,483 --> 00:17:08,200
in the subquery. If it exists, then we're going to return that

287
00:17:08,283 --> 00:17:11,466
content to the outer query and that content will be displayed.

288
00:17:11,483 --> 00:17:14,466
The customer ID specifically and a person ID will display it

289
00:17:14,483 --> 00:17:17,283
that way. And we're going to flip that around and do a not exist

290
00:17:17,366 --> 00:17:17,466
as well.

291
00:17:18,483 --> 00:17:22,466
And both of these will provide us information regarding the exist

292
00:17:22,483 --> 00:17:26,466
or regarding the content that's returned from within that query

293
00:17:26,483 --> 00:17:31,466
or that subquery. All right. Demo using subqueries.

294
00:17:31,483 --> 00:17:38,466
Let's jump out here and take a look at just a couple of those

295
00:17:39,483 --> 00:17:40,466
items that we just looked at.

296
00:17:45,483 --> 00:17:47,466
We'll jump back into SQL Management Studio.

297
00:17:47,483 --> 00:17:49,466
Module 4. I've got to close this out here.

298
00:17:51,483 --> 00:17:54,466
And let's open up one of my other items here.

299
00:17:57,483 --> 00:18:00,466
And so here's a couple items here. So this uses that...

300
00:18:00,483 --> 00:18:03,466
the one that's shown that uses several of those different, it

301
00:18:04,483 --> 00:18:07,466
has the count, the average, the min and max, so we can execute

302
00:18:07,483 --> 00:18:11,450
that here, and you'll see it comes back with unique orders, 31,465

303
00:18:11,483 --> 00:18:15,466
average price. Min order quantity is 1. And the max line total

304
00:18:15,483 --> 00:18:19,0
for a particular order was 27,893.

305
00:18:20,483 --> 00:18:24,466
This one will return the all customers and unique customers for

306
00:18:24,483 --> 00:18:28,466
a salesperson. We saw the... we saw the text for it or the command

307
00:18:28,483 --> 00:18:32,466
for it. I just want to execute it so you see the results for it.

308
00:18:32,483 --> 00:18:35,366
So salesperson ID, we have a few null values. But salesperson

309
00:18:35,450 --> 00:18:41,466
ID 274 in the year 2007 had 14 customers; 13 of them were unique.

310
00:18:41,483 --> 00:18:46,283
2006 had 20 customers; all of them were unique. And same with

311
00:18:46,366 --> 00:18:52,466
2008 and 2005. And, again, we order these by salesperson ID so

312
00:18:52,233 --> 00:18:54,466
we can see how each salesperson is doing.

313
00:18:55,483 --> 00:18:58,466
This here shows us a count of all customers and then sorts them

314
00:18:58,483 --> 00:18:59,466
by salesperson.

315
00:19:01,333 --> 00:19:04,466
So we'll execute that. Here's the salesperson ID. So salesperson

316
00:19:04,483 --> 00:19:10,466
ID 274 has 48 total customers. 275 has 450 total customers.

317
00:19:10,483 --> 00:19:13,466
So this kind of gives us a quick count on how our salespeople

318
00:19:14,400 --> 00:19:18,466
are doing and we can compare that to taking a look at the number

319
00:19:18,483 --> 00:19:20,433
of customers that they have.

320
00:19:21,400 --> 00:19:25,466
Here's the group by the having clause that we saw an example of.

321
00:19:26,300 --> 00:19:28,466
We'll go ahead and execute that. Here's the customer ID.

322
00:19:29,483 --> 00:19:32,466
And we're ordering it by count orders instead, so customer ID

323
00:19:32,483 --> 00:19:37,466
11091 has 20 orders that we have and we're just doing the count.

324
00:19:37,483 --> 00:19:39,466
And we're only looking for those items greater than 10.

325
00:19:39,483 --> 00:19:43,466
Again, we're looking for our most... our more popular customers,

326
00:19:43,483 --> 00:19:46,466
the ones that have at least 10 orders in this particular situation

327
00:19:46,483 --> 00:19:47,466
right here.

328
00:19:50,200 --> 00:19:52,466
Here's the information, returns information about the last order

329
00:19:52,483 --> 00:19:54,466
that was submitted. We saw the query for this. We're going to

330
00:19:54,483 --> 00:19:55,466
execute this now.

331
00:19:57,483 --> 00:20:01,466
And they're saying the sales order ID 75123 was the last order

332
00:20:01,483 --> 00:20:04,466
that was submitted. There were three products that it ordered.

333
00:20:04,483 --> 00:20:10,466
The unit price of each of them was 21.98, 159, and 8.99, and

334
00:20:10,483 --> 00:20:14,466
they ordered one item. So this is the last order that was submitted by...

335
00:20:15,300 --> 00:20:19,466
with... and the sales order ID was 75123. They ordered three

336
00:20:19,483 --> 00:20:23,466
different products. The price for those products and the quantity

337
00:20:24,483 --> 00:20:27,466
of those products that they ordered. Didn't spend a lot of money

338
00:20:27,483 --> 00:20:28,466
there unfortunately.

339
00:20:30,216 --> 00:20:32,316
This one's going to return all the sales orders for each customer

340
00:20:32,400 --> 00:20:36,166
in territory 10. So now we're going to narrow it down to a specific territory.

341
00:20:36,250 --> 00:20:38,466
We want to see what's going on in a specific territory maybe

342
00:20:38,483 --> 00:20:41,433
with a sales manager in that territory.

343
00:20:41,483 --> 00:20:48,466
So customer ID 20042 has a sales order ID, 43708. Supposed to

344
00:20:48,483 --> 00:20:51,466
return information. We could add additional information here.

345
00:20:51,483 --> 00:20:54,466
Notice it's returning 3200 rows.

346
00:20:55,483 --> 00:20:58,466
And so this would give us information about... specifically about

347
00:20:58,483 --> 00:21:02,466
a territory. In this case here, territory ID No. 10, we're going

348
00:21:02,483 --> 00:21:06,166
to look at each customer and each sales order ID associated with

349
00:21:06,250 --> 00:21:09,183
each customer to find out what kind of activity is taking place

350
00:21:09,266 --> 00:21:13,466
in territory No. 10 and only in territory No. 10. And, again,

351
00:21:13,483 --> 00:21:15,466
we could have swapped that out and used additional territories

352
00:21:16,450 --> 00:21:18,466
by changing that clause up there.

353
00:21:19,483 --> 00:21:22,466
This is going to display the person ID for every customer who

354
00:21:22,483 --> 00:21:25,466
has placed an order. This is that exist clause. And we'll go

355
00:21:25,483 --> 00:21:30,466
ahead and execute that. So customer ID 1100, the person ID was 13531.

356
00:21:31,483 --> 00:21:34,466
So every person, this is the person ID associated with the customer

357
00:21:34,483 --> 00:21:38,466
ID for each customer that has placed an order. The exists as

358
00:21:38,483 --> 00:21:42,466
and order had to be placed. So a record has to exist in the sales

359
00:21:42,483 --> 00:21:47,333
order header number... or table in order for them to be returned here.

360
00:21:47,483 --> 00:21:50,316
And you'll see we have 19,000 rows available for that.

361
00:21:52,166 --> 00:21:56,466
And that's getting ahead to the next section. So this is different

362
00:21:56,483 --> 00:22:00,466
ways for us to be able to query content. Specifically we're

363
00:22:00,483 --> 00:22:02,466
trying to use content that is a subquery.

364
00:22:02,483 --> 00:22:06,466
>> Oh, Brian, Brian, Brian. Can I show a demo?

365
00:22:06,483 --> 00:22:10,466
>> Yes, absolutely you could show a demo. In fact, the demo slide's

366
00:22:10,483 --> 00:22:11,233
up just for you.

367
00:22:11,316 --> 00:22:14,466
>> Oh. Wonderful. Okay. So I was just sitting here tinkering and

368
00:22:14,483 --> 00:22:16,433
thinking, so I thought maybe we should show something.

369
00:22:16,450 --> 00:22:16,466
>> That'd be nice.

370
00:22:16,483 --> 00:22:19,466
>> And also looking at the... some questions being asked. So I

371
00:22:19,483 --> 00:22:23,466
wanted to just show this example of derived table and what we

372
00:22:23,483 --> 00:22:26,466
also call common table expressions that can be super useful.

373
00:22:27,483 --> 00:22:30,400
So actually let's just take the example that I showed before

374
00:22:30,483 --> 00:22:35,466
with row number. So we can just start with that and just copy

375
00:22:35,483 --> 00:22:41,466
this thing over. So, again, this is called derived table.

376
00:22:41,200 --> 00:22:45,466
So basically it's a set that you query from. So you use the

377
00:22:45,200 --> 00:22:48,466
subquery in the from clause or the join clause for that matter.

378
00:22:48,483 --> 00:22:53,466
So you can say select from a table inner join, left join, derive table.

379
00:22:53,483 --> 00:22:55,333
That works perfectly.

380
00:22:56,283 --> 00:23:02,466
And in this case this was practical for us to figure out the...

381
00:23:02,483 --> 00:23:04,466
get us these orders based on

382
00:23:06,483 --> 00:23:09,466
the first order for each customer. There is another way of writing

383
00:23:09,483 --> 00:23:14,466
this, which is also very useful, which is using a common table expression.

384
00:23:14,483 --> 00:23:18,466
But the problem a little bit with this is if you write a big

385
00:23:18,233 --> 00:23:21,466
query, now you can imagine how it can look something...

386
00:23:21,483 --> 00:23:23,466
something like this, right?

387
00:23:26,483 --> 00:23:27,466
>> Pretty complex.

388
00:23:27,483 --> 00:23:31,466
>> Exactly. So if you're trying to make sense of it, that can

389
00:23:31,483 --> 00:23:35,466
be somewhat tricky, right? So instead of doing that, you can

390
00:23:35,483 --> 00:23:40,466
use this common table expression thing. So in that you declare

391
00:23:40,483 --> 00:23:43,466
these views, if you will, or derive tables or common table expressions first.

392
00:23:44,483 --> 00:23:49,466
So I can say with A as, this is my set called A, and I can just

393
00:23:49,483 --> 00:23:53,466
copy this, then... this thing in there, and now I have A available

394
00:23:53,483 --> 00:23:57,250
to me. And then I can do my select star from A. And where?

395
00:23:57,483 --> 00:24:01,466
Row number's equal to 1 or rank in this case since I'm using rank.

396
00:24:02,483 --> 00:24:04,466
And it's exactly the same thing. There's no performance difference

397
00:24:04,483 --> 00:24:08,466
or anything like that. But you can imagine now if I have a lot

398
00:24:08,483 --> 00:24:09,466
of these, right,

399
00:24:11,483 --> 00:24:13,466
you would have something that looks like this. And with commas

400
00:24:13,483 --> 00:24:17,466
up here just separating the sets, now my query itself is pretty simple.

401
00:24:17,483 --> 00:24:21,466
I would, okay, I will join, you know, A with B or something and

402
00:24:21,483 --> 00:24:25,450
then I will do left to go in this with this other thing. So becomes

403
00:24:25,483 --> 00:24:28,466
a lot easier to follow the logic of the query if you write it

404
00:24:28,483 --> 00:24:31,466
like this rather than as a derive table.

405
00:24:31,483 --> 00:24:39,466
And so let me show you an example also of this with group by.

406
00:24:39,483 --> 00:24:42,466
So let's say I want to

407
00:24:44,483 --> 00:24:49,316
calculate just orders...

408
00:24:49,483 --> 00:24:53,466
number of orders per customer, this very simple thing. So customer

409
00:24:53,233 --> 00:25:01,466
ID comma sum... or, sorry, just count star. So just number of

410
00:25:02,0 --> 00:25:03,300
orders per customer.

411
00:25:13,483 --> 00:25:14,466
Sales order header.

412
00:25:16,333 --> 00:25:20,466
Group by customer ID. Okay. So I have this query.

413
00:25:21,483 --> 00:25:26,400
Now let's say I want to do something actually a little bit different.

414
00:25:26,483 --> 00:25:29,466
Instead of using customer ID, I would like these grouped by

415
00:25:31,166 --> 00:25:32,466
a calculation instead.

416
00:25:32,483 --> 00:25:38,466
So tie these together. So this is something I typically do is

417
00:25:38,483 --> 00:25:42,166
I often forget what the columns are. So I can just do this and

418
00:25:42,483 --> 00:25:46,466
now I'll easily find the column. So let's say we say, okay,

419
00:25:46,483 --> 00:25:51,466
status 5 is okay and all other statuses address are not okay.

420
00:25:51,483 --> 00:25:57,466
So in that case I'll say something like case when status is equal

421
00:25:57,483 --> 00:26:00,466
to 5, then I want to return okay.

422
00:26:01,400 --> 00:26:03,400
Else I'll say not okay.

423
00:26:04,166 --> 00:26:08,466
Right? End as status.

424
00:26:09,483 --> 00:26:13,466
And since this is grouped by, I now need to go and group by exactly

425
00:26:14,0 --> 00:26:15,466
this full clause, right?

426
00:26:16,483 --> 00:26:18,466
So I need to put that there as well.

427
00:26:19,166 --> 00:26:22,466
Because, again, this column alias status isn't available in the

428
00:26:22,483 --> 00:26:25,466
group by clause because this is really what we're typing, right?

429
00:26:27,166 --> 00:26:31,466
Logically we're starting from then comes group by and then select.

430
00:26:32,483 --> 00:26:33,466
So I'll go and execute this.

431
00:26:34,483 --> 00:26:37,466
You can see it works nice... well, okay, we don't have anything locked.

432
00:26:38,483 --> 00:26:42,416
This status seems super useful, so let's not use that.

433
00:26:46,483 --> 00:26:52,283
Let's use revision number instead just for the example.

434
00:27:01,483 --> 00:27:11,466
Okay. Oh, sorry, is equal to 3. Ah. There we go. Okay and sum

435
00:27:11,483 --> 00:27:15,466
not okay. Now, this is officially somewhat irritating that you

436
00:27:15,483 --> 00:27:17,466
are to repeat the case expression.

437
00:27:18,266 --> 00:27:21,266
But with a derived table... common table expression I don't need to.

438
00:27:21,350 --> 00:27:25,333
I can say with A as I define the expression

439
00:27:26,483 --> 00:27:27,466
and then

440
00:27:32,483 --> 00:27:35,200
I don't have the count here anymore. This is just my...

441
00:27:35,283 --> 00:27:38,466
this is the full set that I need, right, so I can do a select

442
00:27:38,483 --> 00:27:39,400
star from A,

443
00:27:42,483 --> 00:27:46,466
which works fine. I get all of the rows back. And now...

444
00:27:46,483 --> 00:27:49,466
obviously now status is a normal column. Right? So now I can

445
00:27:49,483 --> 00:27:55,466
just say, okay, from a group by status, and I would like to get

446
00:27:55,216 --> 00:27:58,466
the status and I want the count.

447
00:28:03,483 --> 00:28:08,316
And now this works fine. Right? So these common table expressions

448
00:28:08,400 --> 00:28:12,466
or derived tables can greatly help you simplify your queries.

449
00:28:12,483 --> 00:28:16,466
Now you may ask, oh, isn't this less performant because clearly

450
00:28:16,483 --> 00:28:21,450
we'll generate this full set and then you'll go ahead and basically

451
00:28:21,483 --> 00:28:24,466
do the calculation on top of this. So what we do in the query

452
00:28:24,483 --> 00:28:28,450
optimization is we... one of the big first steps we do is flatten

453
00:28:28,483 --> 00:28:32,466
the query. So it's not always the case, but, typically, however

454
00:28:32,483 --> 00:28:36,466
you write it through a view derived tabled common table expression,

455
00:28:36,483 --> 00:28:40,466
when it hits the query optimizer, it's just like the flat query

456
00:28:40,483 --> 00:28:43,333
that you would have written directly against the table with none

457
00:28:43,483 --> 00:28:45,466
of these. So they shouldn't actually affect performance.

458
00:28:48,483 --> 00:28:51,466
>> All right. Excellent. Thanks very much, Tobias, for explaining

459
00:28:51,483 --> 00:28:54,466
that for us. We're going to talk about some table functions and

460
00:28:54,483 --> 00:28:59,466
focus just on some of the details on using table functions.

461
00:28:59,183 --> 00:29:01,466
We're going to begin by talking about a sample view. And this

462
00:29:01,483 --> 00:29:04,466
is very simple. And, remember, a view is not an object that's

463
00:29:04,483 --> 00:29:08,466
stored in a database. It's role in object at... it's a query object.

464
00:29:08,483 --> 00:29:12,300
So when I go out and execute a statement, a select statement

465
00:29:12,383 --> 00:29:15,466
against a view, it's actually grabbing the information or retrieving

466
00:29:15,483 --> 00:29:19,466
the information from underlying tables as through this view.

467
00:29:19,166 --> 00:29:21,466
So we're going to create the view called humanresource.employee

468
00:29:21,483 --> 00:29:25,466
list as we're going to select four rows or four columns from

469
00:29:25,483 --> 00:29:28,466
the humanresources.employee, and then we can turn around and

470
00:29:28,483 --> 00:29:31,466
do a select asterisk from that employee list. So now I've got

471
00:29:31,483 --> 00:29:36,466
a view and I can restrict the view. So I may have 15, 20 columns

472
00:29:36,166 --> 00:29:39,466
in the employee lists, and there's probably only four or five

473
00:29:39,483 --> 00:29:42,466
I want some of my... or some individuals to see. But what I

474
00:29:42,483 --> 00:29:45,466
can do is create a view, give them permission to access the view,

475
00:29:45,483 --> 00:29:48,466
and the view will only return that content to them or those four

476
00:29:48,483 --> 00:29:51,466
rows that they have permissions that are displayed in the view

477
00:29:51,483 --> 00:29:56,0
that they have permissions to see. Now, this is showing an example

478
00:29:56,483 --> 00:29:58,416
of creating a view with just one underlying table. You could

479
00:29:58,483 --> 00:30:00,466
actually create a view with multiple underlying tables. We could

480
00:30:00,483 --> 00:30:04,466
use join statement and get information from the employee list

481
00:30:04,483 --> 00:30:07,466
and the employee address list if we wanted to. Or employee list,

482
00:30:07,483 --> 00:30:10,466
we want to see how many employees are also customers, have bought

483
00:30:10,483 --> 00:30:13,466
some of our product. So we could actually use a join statement

484
00:30:13,483 --> 00:30:17,466
here to make this a little bit more complex. But this view here

485
00:30:17,483 --> 00:30:19,466
is just going to take four columns from our employee...

486
00:30:19,483 --> 00:30:23,466
from our employee table and create a view of them. Now I can

487
00:30:23,483 --> 00:30:27,466
get permissions to individuals to access the view without giving

488
00:30:27,483 --> 00:30:31,466
them permissions to access the other columns within that...

489
00:30:31,483 --> 00:30:35,466
within that underlying table. And, again, I could add additional

490
00:30:35,483 --> 00:30:39,466
columns from other tables to ensure that my users are seeing...

491
00:30:39,483 --> 00:30:43,233
are able to see additional content in this view. And, again,

492
00:30:43,316 --> 00:30:45,466
they're not stored... it's not stored as an object, it's more

493
00:30:45,483 --> 00:30:49,466
of a query object here. The table value functions are created

494
00:30:49,483 --> 00:30:52,466
by administrators and developers. We can create a name, a function,

495
00:30:53,483 --> 00:30:55,466
using a create function here. We're creating a function here

496
00:30:55,483 --> 00:30:59,466
for a line total. We're going to pass a parameter called sales

497
00:30:59,483 --> 00:31:03,466
order ID. Notice that's what unique about this, it returns a

498
00:31:03,483 --> 00:31:08,466
type called table. So instead of a scalar function or a value

499
00:31:08,483 --> 00:31:11,466
or a group of values be returned, this actually returns a table.

500
00:31:12,483 --> 00:31:15,466
And then it uses as return, and there's a select statement in

501
00:31:15,483 --> 00:31:18,466
there, and it's going to actually use the cast to do a conversion

502
00:31:19,400 --> 00:31:23,466
and then it's going to create a field as decimal 8 comma 2, and

503
00:31:24,483 --> 00:31:26,466
it's going to grab the information sales order detail.

504
00:31:26,483 --> 00:31:31,450
Where, the sales order ID equal the path's variable, whatever

505
00:31:31,483 --> 00:31:34,466
we passed in for the sales order ID. So it's going to match

506
00:31:34,183 --> 00:31:37,466
it up and it's going to execute or perform this function based

507
00:31:37,483 --> 00:31:42,466
on the sales order ID and compare that in that where clause to

508
00:31:42,200 --> 00:31:44,433
perform that function.

509
00:31:46,483 --> 00:31:49,466
Derive tables are name query expressions created with an outer

510
00:31:49,483 --> 00:31:52,216
select statement. I think we just saw a good idea of those.

511
00:31:53,483 --> 00:31:57,466
Derived tables must have an alias, have names for all columns...

512
00:31:57,483 --> 00:32:00,466
every column has to have a name... have unique names for every

513
00:32:00,483 --> 00:32:05,466
column, are not used in an order by clause, and cannot be referred

514
00:32:05,483 --> 00:32:10,466
to multiple times in the same query. So a few ideas about how

515
00:32:10,483 --> 00:32:14,466
derived tables are used. They may be internal or external aliases

516
00:32:14,483 --> 00:32:17,466
or use internal or external aliases, they may refer to parameters

517
00:32:18,333 --> 00:32:22,466
and/or variables, and they may be nested within other derived tables.

518
00:32:22,483 --> 00:32:25,466
So there's some restrictions and there's some limitations or

519
00:32:25,483 --> 00:32:28,466
limitations that you can be... you should be aware of when you're

520
00:32:28,483 --> 00:32:32,466
looking at the use of these derived tables. We can pass arguments

521
00:32:32,483 --> 00:32:36,333
to derived tables. We're going to declare a variable here called

522
00:32:36,416 --> 00:32:41,450
emp ID of int time with 9. We're going to select order year.

523
00:32:41,483 --> 00:32:44,466
We're going to do a count distinct as customer count. And then

524
00:32:44,483 --> 00:32:48,466
we're going to perform the query. Select year as order date.

525
00:32:48,183 --> 00:32:50,466
And then... or select year... a portion of the order date as

526
00:32:50,483 --> 00:32:54,466
order year, customer ID, from the sales order table where emp

527
00:32:54,483 --> 00:32:58,466
ID equal to past emp ID with a declared variable. And we're

528
00:32:58,483 --> 00:33:01,466
going to set this up as a derived year. And then we're going

529
00:33:01,483 --> 00:33:04,466
to group this by order year. And this will give us information

530
00:33:04,483 --> 00:33:11,466
about the order year on the distinct customer IDs and the number

531
00:33:12,366 --> 00:33:17,466
of items that customers purchase for a particular year. And we're

532
00:33:17,483 --> 00:33:21,466
going to pass the ID of that customer in as a variable when we

533
00:33:21,483 --> 00:33:25,466
run this... or use this derived table.

534
00:33:26,466 --> 00:33:29,300
Now, the CTEs, or common table expressions, we just got a nice

535
00:33:29,383 --> 00:33:34,466
demo from Tobias on this. With CTE year as. We're going to select

536
00:33:34,483 --> 00:33:39,183
a year order date as order year, customer ID. And then we're

537
00:33:39,266 --> 00:33:41,466
going to go in, we're going to do a select order year with a

538
00:33:41,483 --> 00:33:45,466
count distinct customer ID as customer count. From the CTE year,

539
00:33:45,483 --> 00:33:48,466
which is what we decided... what we define, excuse me, with the

540
00:33:48,483 --> 00:33:52,466
with clause. And then we're going to group by the order year.

541
00:33:52,483 --> 00:33:55,466
So this allows us... and, again, this is the demo, this is an

542
00:33:55,483 --> 00:34:03,466
example of what Tobias just demoed for us just a few moments ago.

543
00:34:03,483 --> 00:34:05,466
Are there any other functions that you're interested in demoing

544
00:34:05,483 --> 00:34:07,466
in this particular module?

545
00:34:07,483 --> 00:34:10,433
>> I can go ahead and demo just the table valued functions.

546
00:34:10,450 --> 00:34:10,466
>> Okay.

547
00:34:10,483 --> 00:34:14,0
>> And talk a little bit about that. So basically why would you

548
00:34:14,483 --> 00:34:18,466
use a view versus a table valued function. And there are two

549
00:34:18,216 --> 00:34:20,383
types of table valued functions. There are the inline table

550
00:34:20,466 --> 00:34:24,166
valued that we shown on the slide, and you can also do multistatement

551
00:34:24,250 --> 00:34:27,466
table valued functions, which are a little bit more complex and

552
00:34:27,483 --> 00:34:31,466
you can use for somewhat different types of problems. But typically

553
00:34:31,483 --> 00:34:34,466
the table valued function, it's just a view. It's a view that

554
00:34:34,483 --> 00:34:38,466
takes parameters, really nothing else. So it's useful for you

555
00:34:38,483 --> 00:34:42,466
if you want to force queries to look a certain way. And it's

556
00:34:42,483 --> 00:34:46,316
fairly common that you want to say, well, if you search this

557
00:34:46,400 --> 00:34:49,466
table you really should search on dates because I have an index

558
00:34:49,483 --> 00:34:50,466
on dates.

559
00:34:51,483 --> 00:34:55,466
So as an example, we may say, okay, we want a function or a view

560
00:34:56,166 --> 00:34:59,466
that gives us just total purchases per customer, let's say.

561
00:35:01,483 --> 00:35:03,466
So let's just call this sales.fn

562
00:35:05,483 --> 00:35:07,466
customer sales.

563
00:35:08,483 --> 00:35:12,466
And we require you to take start date

564
00:35:14,483 --> 00:35:20,466
and end or pass and end date as parameters.

565
00:35:21,483 --> 00:35:26,466
We'll use the data type date. And returns table. Now, again,

566
00:35:26,483 --> 00:35:29,466
returns table doesn't mean we create some sort of table in some

567
00:35:29,483 --> 00:35:32,466
special way. It's no different from using a common table expression,

568
00:35:32,483 --> 00:35:34,466
a derived table or a view.

569
00:35:35,483 --> 00:35:39,466
As return and then we have this query. And originally this is

570
00:35:39,483 --> 00:35:42,466
now stored in metadata, so that's the big difference from using

571
00:35:42,483 --> 00:35:47,466
the inline to the CT or the derived table that now you have stored

572
00:35:47,483 --> 00:35:51,466
this so you can reuse it as much as you want. So we'll just

573
00:35:51,483 --> 00:35:53,466
do the simple thing of select customer ID...

574
00:35:57,483 --> 00:35:59,466
or customer ID comma...

575
00:35:59,483 --> 00:36:03,466
I think it's called company name.

576
00:36:04,333 --> 00:36:07,283
And then just say some of something.

577
00:36:11,366 --> 00:36:14,466
So from customer table, and then I'll do a left outer join.

578
00:36:14,483 --> 00:36:18,466
Because I want to include also customers that didn't buy anything.

579
00:36:18,483 --> 00:36:21,466
Sales.sales order header

580
00:36:23,483 --> 00:36:27,350
on sales order header...

581
00:36:27,483 --> 00:36:33,466
sorry, customer ID is equal to customer ID in the customer's table.

582
00:36:33,483 --> 00:36:37,466
And then I want to go and continue running into the sales order

583
00:36:37,483 --> 00:36:39,466
detail table to get the actual prize.

584
00:36:41,483 --> 00:36:47,466
So where sales order ID is equal to sales order ID. And then

585
00:36:47,483 --> 00:36:52,466
now I want to group this by the customer. So customer ID and

586
00:36:52,483 --> 00:36:55,466
I want it to include, okay, let's say a count number as well.

587
00:36:57,400 --> 00:36:58,466
And I want to sum the

588
00:37:01,450 --> 00:37:04,466
unit price, let's just say, as a simple example. And I want...

589
00:37:04,483 --> 00:37:08,466
if this happens to be... now, if we don't find... so if there

590
00:37:08,483 --> 00:37:09,466
are no orders,

591
00:37:11,333 --> 00:37:15,333
we'll get null returned, right, so the sum has nothing to sum up.

592
00:37:16,483 --> 00:37:20,466
Something weird going on here. Okay. So I'll just say if this

593
00:37:20,483 --> 00:37:24,466
returns null, I want to see a return as total sales.

594
00:37:24,483 --> 00:37:30,466
So we go ahead and create this function. Oh, sorry. And then

595
00:37:32,466 --> 00:37:36,466
we require this filtering. So where the order date

596
00:37:38,316 --> 00:37:40,466
is greater than or equal to

597
00:37:42,483 --> 00:37:51,466
my start date that I passed in, and order date is let's say less than...

598
00:37:52,483 --> 00:37:55,466
just to make it easy, end date. So end date is exclusive in this

599
00:37:55,483 --> 00:37:57,466
case, just for simplicity.

600
00:37:58,483 --> 00:38:02,466
So now obviously I force whoever is querying my function to go

601
00:38:02,483 --> 00:38:06,466
and use the order... if I have an order date index, presumably

602
00:38:06,483 --> 00:38:08,466
that can be used depending a little bit on what other indexes

603
00:38:08,483 --> 00:38:11,466
I have on the other two tables. But I'll create the function.

604
00:38:11,483 --> 00:38:23,466
Oops. Some unit price, oh, sales order ID. So it should be order date.

605
00:38:23,483 --> 00:38:25,466
It's hard to compare an integer with the date.

606
00:38:26,483 --> 00:38:30,283
So now we have the function, and now we can just go ahead and

607
00:38:30,366 --> 00:38:33,466
query and say, well, I would like to get everything from here

608
00:38:35,333 --> 00:38:45,466
and starting with 2011, January, and less than 2012, let's say.

609
00:38:46,483 --> 00:38:47,466
Or 2013.

610
00:38:52,483 --> 00:38:55,0
And there's nothing there, so let's go further back.

611
00:38:57,483 --> 00:39:02,383
There we go. So just an example of using an inline table valued function.

612
00:39:03,483 --> 00:39:05,466
>> How many keyboards do you go through in a week? A month?

613
00:39:05,483 --> 00:39:06,466
>> Well, I'll use this... I'm actually...

614
00:39:06,483 --> 00:39:09,466
>> I see that one smoking already. It's only been a few hours.

615
00:39:09,483 --> 00:39:12,466
>> The big problem here is... so this is... someone asked about...

616
00:39:12,483 --> 00:39:16,466
so this is... it's not integrated. It's part of... it's a separate keyboard.

617
00:39:16,483 --> 00:39:20,466
But every time I go to Sweden I always buy a Swedish keyboard,

618
00:39:20,216 --> 00:39:23,466
so I used to... I should have brought one here today, but I forgot.

619
00:39:23,483 --> 00:39:25,466
>> Well, I'm glad you didn't. Because if you're typing that fast

620
00:39:25,483 --> 00:39:28,466
on a U.S. keyboard, I can't imagine how fast you type on a Swede keyboard.

621
00:39:28,483 --> 00:39:30,466
>> Yeah, and it will also be...

622
00:39:30,483 --> 00:39:31,466
>> Fire extinguisher over by the keyboard?

623
00:39:32,166 --> 00:39:34,466
>> Yeah. I would say not select, but it's [Speaking Swedish].

624
00:39:35,366 --> 00:39:38,466
Yeah, it would be different.

625
00:39:38,483 --> 00:39:41,466
>> Well, you're doing great. Definitely. My hands are getting

626
00:39:41,483 --> 00:39:42,466
tired watching you type.

627
00:39:44,216 --> 00:39:46,266
All right. So let's just go ahead and do just a little bit of

628
00:39:46,350 --> 00:39:49,466
review for this module here. We introduce... so three of the

629
00:39:49,483 --> 00:39:53,466
common built-in aggregate function categories, the common, the

630
00:39:53,483 --> 00:39:57,466
statistical, and then the other category. We saw a demo on several

631
00:39:57,483 --> 00:40:01,466
of these as we went through, especially under the common ones

632
00:40:01,183 --> 00:40:03,466
on the other column. So we went through and saw some of these

633
00:40:04,483 --> 00:40:08,466
examples of these. We also talked about more detail on the distinct clause.

634
00:40:08,483 --> 00:40:12,466
We saw some information and detail about the group by and having clause.

635
00:40:12,483 --> 00:40:15,466
And we get some really good information on the demos when we

636
00:40:15,483 --> 00:40:20,466
did the scalar subqueries and multiple value subqueries.

637
00:40:21,483 --> 00:40:26,266
And then Tobias rocked with the table valued functions and the

638
00:40:26,350 --> 00:40:30,333
CTEs and the derived tables. Had some great... some demonstrations

639
00:40:30,416 --> 00:40:31,466
on those as well.

640
00:40:32,333 --> 00:40:35,466
And we also get to peek at how to create a function, one of these

641
00:40:35,483 --> 00:40:39,466
table valued functions and how can we use the return type of

642
00:40:39,483 --> 00:40:42,466
a table which is unique for something that we're... in comparison

643
00:40:42,483 --> 00:40:46,466
to what we normally use. So this is going to wrap up Module 4.

644
00:40:46,483 --> 00:40:50,466
And what we're going to do now is take a meal break. So here

645
00:40:50,483 --> 00:40:54,466
in Washington it is almost... it's about quarter to 12:00, so

646
00:40:54,183 --> 00:40:57,466
we'll return at about an hour from now. So we're going to take

647
00:40:57,483 --> 00:41:00,466
60 minutes, depending on what time zone you are in the world,

648
00:41:00,483 --> 00:41:04,466
60 minutes, roughly 60 minutes, 45 minutes past the next hour,

649
00:41:04,233 --> 00:41:04,466
wherever you may be.

650
00:41:04,483 --> 00:41:06,466
>> Wherever you are, it's still 60 minutes, right?

651
00:41:06,483 --> 00:41:09,466
>> It's still 60 minutes no matter where you are. So it doesn't

652
00:41:09,483 --> 00:41:11,466
matter where you are. It's always 60 minutes. So I don't know

653
00:41:12,333 --> 00:41:13,466
what the time frame is going to be on your clock, but...

654
00:41:13,483 --> 00:41:16,466
>> If it's not 60 minutes in Fahrenheit or there's something.

655
00:41:16,483 --> 00:41:19,166
>> No, it's not that way.

656
00:41:19,483 --> 00:41:21,350
>> No? Okay. Just checking.

657
00:41:21,433 --> 00:41:24,466
>> Regular time. Thank goodness. So all right. So eat up, drink

658
00:41:24,483 --> 00:41:27,466
up, recharge for this afternoon or remaining modules that we

659
00:41:27,483 --> 00:41:30,466
have, because it may not be afternoon for you. We'll be back

660
00:41:30,483 --> 00:41:34,466
in about 60 minutes, 45 minutes past the next hour, and we'll

661
00:41:34,483 --> 00:41:37,466
continue on with our discussion. We still have four great modules

662
00:41:37,483 --> 00:41:41,466
left for us to discuss later on today, and we look forward to

663
00:41:41,483 --> 00:41:44,466
seeing you back here in about 60 minutes. Thank you for joining us.

664
00:41:44,483 --> 00:41:47,466
>> Thank you.

