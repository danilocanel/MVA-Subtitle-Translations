1
00:00:00,333 --> 00:00:06,333
[Música]

2
00:00:12,483 --> 00:00:20,466
>> Vamos a entrar en nuestro próximon módulo y avanzar a un nivel superior.

3
00:00:20,483 --> 00:00:23,466
Vamos a introducirnos en las instrucciones SELECT avanzadas,

4
00:00:24,483 --> 00:00:26,466
y en las instrucciones SELECT avanzadas, vamos a hablar

5
00:00:26,483 --> 00:00:29,466
aqui, a medida que avanzamos, iremos hablando acerca

6
00:00:29,483 --> 00:00:34,466
de cosas como la clausula DISTINCT, la aliases, la funcion scalar,

7
00:00:35,333 --> 00:00:39,466
uso de CASE, JOINS y MERGEs. Empezaremos con eso.

8
00:00:39,483 --> 00:00:44,383
Filtracion de datos, clasificacion de datos y como trabajamos con los valores nulos.

9
00:00:44,483 --> 00:00:46,466
Asi que aqui finalizamos con el primer modulo,

10
00:00:46,483 --> 00:00:49,466
y vamos a avanzar a un nivel superior e iniciar a trabajar

11
00:00:49,483 --> 00:00:53,466
con algunas de las opciones avanzadas que tenemos a nuestra disposición.

12
00:00:53,483 --> 00:00:55,250
Anteriormente dimos una pequeña introducción... hablamos acerca

13
00:00:55,333 --> 00:00:57,466
de la clasificación y el filtrado cuando se utiliza la cláusula WHERE,

14
00:00:57,483 --> 00:01:00,466
que no hizo mucho con JOINs, Peor ahora hablaremos

15
00:01:00,483 --> 00:01:03,466
de cláusulas mas avanzadas que podemos

16
00:01:03,483 --> 00:01:06,333
utilizar con la intrucción SELECT.

17
00:01:06,483 --> 00:01:09,466
Tobias, ¿Cómo me ayudará esta sentencia DISTINCT aqui?

18
00:01:10,0 --> 00:01:15,466
>> La sentencia DISTINCT se refiere a tolo lo relacionado a la eliminación de duplicados en un conjunto, y

19
00:01:16,483 --> 00:01:18,466
normalmente se utiliza por

20
00:01:19,483 --> 00:01:24,466
si deseas tener todos los primeros nombres de una tabla, y tiene

21
00:01:24,483 --> 00:01:27,466
bastantes Jonh y aun más Tobias, porque es obvio que es

22
00:01:27,483 --> 00:01:32,400
un nombre muy común. Y asi, si solo dices SELECT primer nombre

23
00:01:32,483 --> 00:01:36,466
de los empleados o lo que sea, simplemente le dara toda los

24
00:01:36,166 --> 00:01:38,466
nombres sin ningun orden en particular, pero si usted dice DISTINCT, se

25
00:01:38,483 --> 00:01:41,466
le dará la combinación única en todas las columnas, por lo que es

26
00:01:41,483 --> 00:01:45,466
algo importante que debemos recordar. DISTINCT ira a través de toda la fila.

27
00:01:45,483 --> 00:01:49,233
No se ve en una columna especifica. si no que es a través de

28
00:01:49,316 --> 00:01:52,466
toda la fila que va a proyectar, y luego

29
00:01:52,483 --> 00:01:58,466
da el resultado de nuevo sin los duplicados. Es importante

30
00:01:58,483 --> 00:02:03,466
conocer que DISTINCT es normalmente una declaracion bastante grande de

31
00:02:03,483 --> 00:02:07,466
mantener, por lo que cuanto mayor sea el conjunto, mas trabajo tendríamos que hacer para

32
00:02:07,483 --> 00:02:11,466
aprobar estos duplicados. Por lo general incluye clasificar el resultado

33
00:02:11,483 --> 00:02:14,466
primero y luego ir a través de la eliminacion y que, como era de esperarse

34
00:02:14,483 --> 00:02:17,466
si lo que se necesita para eliminar los duplicados de un conjunto,

35
00:02:17,233 --> 00:02:19,466
que tendría que hacer algo asi.

36
00:02:20,483 --> 00:02:25,466
>> Efectivamente. Y entonces aquí hay un ejemplo de la utilización de un StoreID SELECT DISTINCT .

37
00:02:25,483 --> 00:02:28,466
Así que si acabo de hacer un SELECT desde StoreID Sales.Customer, que va

38
00:02:28,483 --> 00:02:32,466
a mostrar múltiples ocurrencias de StoreID. Al arrojar la

39
00:02:32,483 --> 00:02:35,466
cláusula DISTINCT allí, ahora que va a mostrarme cada

40
00:02:35,183 --> 00:02:38,466
StoreID, o que va a mostrar que una vez, cada StoreID, que

41
00:02:38,483 --> 00:02:40,466
sea como usted dijo. Es un poco más arriba, pero

42
00:02:40,483 --> 00:02:43,466
mi conjunto de resultados va a tener uno mas pequeño.

43
00:02:43,483 --> 00:02:46,466
>> Y es importante, esto de rendimiento. Probablemente vamos a

44
00:02:46,483 --> 00:02:48,466
hablar un poco acerca de rendimiento a lo largo del día.

45
00:02:49,483 --> 00:02:53,250
Pero primero viene funcionalidad, ¿verdad? Primero tiene que obtener los

46
00:02:53,333 --> 00:02:55,466
resultados que usted está realmente interesado, y luego desea

47
00:02:55,483 --> 00:02:59,466
optimizar esto. Y, obviamente, en lo que respecta a los resultados,

48
00:02:59,483 --> 00:03:01,466
cuanto más se puede restringir y cuanto más se puede entender 

49
00:03:01,483 --> 00:03:06,200
exactamente lo que se necesita, probablemente, el más usted puede ajustar el rendimiento.

50
00:03:06,283 --> 00:03:09,250
Pero al final del día, no se puede utilizar una declaración general

51
00:03:09,333 --> 00:03:12,466
como nunca para uso distinto, porque si no desea que los duplicados

52
00:03:12,483 --> 00:03:15,466
de allí, es de suponer que se deben utilizar DISTINCT.

53
00:03:15,483 --> 00:03:17,466
>> Sí. Siempre y cuando se entienda la sobrecarga que implica, como ya

54
00:03:17,483 --> 00:03:19,466
dijimos, no van a haber momentos en los que vas a tener que

55
00:03:19,483 --> 00:03:23,466
usarlo, pero siempre y cuando usted entienda la sobrecarga que está involucrado

56
00:03:23,483 --> 00:03:26,466
con eso, vas a ser capaz de ejecutar con eso. He aquí algunos

57
00:03:26,483 --> 00:03:30,466
utilizando aliases. Aquellos ayuda tipo de formato. Una vez más, vamos

58
00:03:30,183 --> 00:03:33,466
a mirar las diferentes formas en las que podríamos controlar los resultados y

59
00:03:33,483 --> 00:03:36,466
nuestro conjunto de resultados, por lo que hemos llamando a los aliases de aquí, donde tenemos

60
00:03:36,483 --> 00:03:41,466
got seleccionar la cantidad SalesOrderID, UnitPrice, orden, como la cantidad.

61
00:03:41,483 --> 00:03:43,466
Así que esa es la forma en que se va a mostrar eso. Así que esto es mediante

62
00:03:43,483 --> 00:03:47,466
la adición de un aliases para una columna mediante el uso de la cláusula AS. Podemos

63
00:03:47,483 --> 00:03:52,466
hacer algo muy similar con sólo utilizar el nuevo editor de columnas.

64
00:03:52,483 --> 00:03:56,466
Ponemos Cantidad = OrderQty, por lo que echó por tipo de estos en todo

65
00:03:56,483 --> 00:03:59,466
sin la cláusula AS, por lo que la nueva cabecera de la columna está a la

66
00:03:59,483 --> 00:04:03,466
izquierda del signo igual, como lo es en comparación con el derecho de

67
00:04:03,483 --> 00:04:07,466
el AS. También puede aliases de columna accidentales. Me gusta este.

68
00:04:07,483 --> 00:04:12,316
Tenemos identificación de la orden de venta, el precio unitario y la cantidad de Sales.SalesOrderDetail.

69
00:04:12,483 --> 00:04:17,466
Notice I didn't put a comma after unit price, so this is why

70
00:04:17,483 --> 00:04:21,466
Note que no puse una coma después de precio por unidad, por lo que esta es la razón por

71
00:04:21,483 --> 00:04:26,466
la que me dan contenido que es el precio unitario con la cabecera de la cantidad.

72
00:04:26,483 --> 00:04:29,466
Es el orden correcto, ¿O voy a la inversa? No puedo recordar.

73
00:04:29,483 --> 00:04:30,466
Lo veremos.

74
00:04:31,483 --> 00:04:35,466
Porque hay contenidos allí sin la coma, es la identificación de

75
00:04:35,483 --> 00:04:38,183
cantidad como encabezado de la columna, pero va a mostrar en realidad

76
00:04:38,266 --> 00:04:39,466
UnitPrice alli.

77
00:04:40,483 --> 00:04:42,466
>> Así, con respecto a esto, usted puede preguntarse, ¿por qué tengo tres

78
00:04:43,333 --> 00:04:47,466
maneras diferentes de hacer la misma cosa? ¿Es justo que la gente se confunda?

79
00:04:48,483 --> 00:04:52,466
No. Entonces, básicamente, como es lo que debes usar. AS es lo que se

80
00:04:52,483 --> 00:04:57,466
define en el estándar ANSI SQL. Por eso apoyamos iguales y

81
00:04:57,483 --> 00:05:01,466
básicamente, sin hacer de forma adicional, así que eso es lo que se ve

82
00:05:02,166 --> 00:05:05,466
en la parte inferior existe, es debido a razones de herencia. Así que una de

83
00:05:05,483 --> 00:05:09,400
las cosas que hacemos muy bien en SQL Server es mantener la

84
00:05:09,483 --> 00:05:13,383
compatibilidad hacia atrás trabajando para usted. Así que, básicamente, si introducimos

85
00:05:13,466 --> 00:05:17,466
algo, aunque sea hace mucho, mucho tiempo, todavía se puede

86
00:05:19,183 --> 00:05:22,166
ejecutar el comando en la actualidad. La única vez que vamos y quitarlo es básicamente

87
00:05:22,250 --> 00:05:26,200
si causa problemas. Por lo que es muy aconsejable utilizar AS,

88
00:05:26,283 --> 00:05:29,466
ya que es la forma en ANSI SQL de escribirlo, pero estas otras

89
00:05:29,483 --> 00:05:30,466
maneras, también.

90
00:05:32,233 --> 00:05:35,466
>> Muy bien, la bondad de la idea de aliases se hace la columna

91
00:05:35,483 --> 00:05:37,466
de cabeceras un poco más manejable, porque a veces el que

92
00:05:37,483 --> 00:05:41,466
diseñó la base de datos no puede tener los títulos de las columnas más fácil de usar.

93
00:05:41,483 --> 00:05:44,466
Ahora podemos definir aquellos un poco diferente. Aliases para

94
00:05:44,483 --> 00:05:46,466
hacer referencia a las tablas, que vio cómo lo hicimos un poco antes.

95
00:05:46,483 --> 00:05:51,466
Tenemos SELECT SalesOrderID, ProductID, a partir de esta tabla Sales.SalesOrderDetail

96
00:05:52,333 --> 00:05:57,466
AS SalesOrders. Ahora puedo hacer referencia a esta tabla tiene órdenes de venta

97
00:05:57,483 --> 00:06:00,466
en futuras declaraciones aquí. Esto es un poco más para las columnas.

98
00:06:00,483 --> 00:06:03,466
Ahora es sin el AS, y luego tenemos los aliases de tabla en una

99
00:06:03,483 --> 00:06:08,466
cláusula SELECT, y eso es lo que hicimos antes, en mi demo anterior.

100
00:06:08,483 --> 00:06:12,466
Una vez defino, o si me identifico órdenes de venta hasta aquí con la

101
00:06:13,333 --> 00:06:16,466
cláusula AS, o si uso una cláusula AS, tengo que especificar que en

102
00:06:16,483 --> 00:06:21,466
la instrucción SELECT. Así que eso es sólo el uso de las tablas como

103
00:06:21,483 --> 00:06:22,466
un aliases.

104
00:06:22,483 --> 00:06:25,466
>> Así que ¿para qué usar estos alias de tabla?

105
00:06:25,483 --> 00:06:27,466
>> Bueno, si estás haciendo ... vamos a hablar de uniones.

106
00:06:27,483 --> 00:06:30,466
Si vas a ser capaz de hacer referencia, tal vez, una mesa o varias

107
00:06:30,483 --> 00:06:34,466
tablas o una tabla varias veces usando diferentes nombres, como

108
00:06:34,483 --> 00:06:37,466
dentro de una combinación, estos van a ser beneficioso cuando vemos la

109
00:06:37,483 --> 00:06:39,166
une a un poco más tarde.

110
00:06:39,483 --> 00:06:42,466
>> Sí, y también le ayudará de escribir demasiado. Si

111
00:06:42,483 --> 00:06:46,416
necesita hacer referencia a este nombre de la tabla todo el tiempo, que le ayudará

112
00:06:46,483 --> 00:06:48,466
si utiliza los alias y los hacen más cortos.

113
00:06:51,200 --> 00:06:53,466
>> Expresiones CASE. Una expresión CASE sencilla, vamos a hablar de ellos.

114
00:06:53,483 --> 00:06:58,433
Esto nos permite comparar un valor de una lista de posibles valores

115
00:06:58,483 --> 00:07:00,466
y luego realizar alguna ...

116
00:07:01,483 --> 00:07:05,466
una declaración sobre la base de los resultados de esa. Expresiones CASE

117
00:07:05,483 --> 00:07:09,466
se pueden utilizar en su columna de SELECT, donde tienen cláusulas ORDER BY.

118
00:07:09,483 --> 00:07:14,466
Y se muestra un ejemplo de estos aquí, donde tenemos

119
00:07:14,483 --> 00:07:15,466
SelectProductID, Name

120
00:07:17,250 --> 00:07:20,466
y ProductSubCategoryID, CASE ProductSubCategoryID, WHEN 1,

121
00:07:20,483 --> 00:07:23,466
entonces es igual a las bebidas. ELSE, es una categoría desconocida.

122
00:07:23,483 --> 00:07:26,466
Así que más o menos se va a ir hacia abajo a través, y cuando se encuentra

123
00:07:26,483 --> 00:07:30,433
que los ProductSubCategoryID es igual a 1, vamos a saber

124
00:07:30,483 --> 00:07:34,466
que es bebidas. De lo contrario, se va a mostrar como una categoría desconocida.

125
00:07:34,483 --> 00:07:37,416
Así que cuando hago una demo, te voy a mostrar este comando específicamente

126
00:07:37,483 --> 00:07:40,466
para que tenga una mejor idea aquí en cuanto a cómo se ve

127
00:07:40,183 --> 00:07:40,466
en acción.

128
00:07:43,416 --> 00:07:44,466
De hecho, vamos a hacer eso ahora.

129
00:07:46,400 --> 00:07:50,466
Entonces, ¿qué voy a hacer? es que voy a volver a mi imagen,

130
00:07:53,483 --> 00:07:54,466
y así

131
00:07:57,300 --> 00:08:01,350
voy a ir y voy a cargar una declaración hacia arriba, una consulta

132
00:08:02,366 --> 00:08:05,466
que ya había escrito. Ustedes no me quieren ver todo lo que eo

133
00:08:06,483 --> 00:08:08,466
dedo gordo, así que tengo algunas declaraciones aquí. Hablamos

134
00:08:08,483 --> 00:08:11,466
un poco sobre la DISTINCT aquí, así que sólo podemos correr muy

135
00:08:11,483 --> 00:08:15,466
rápido por lo que podemos ver que en la acción. Así SELECT DISTINCT StoreID.

136
00:08:15,483 --> 00:08:19,466
Permítanme aprovechar esta. Así que podemos ejecutar este de aquí.

137
00:08:22,483 --> 00:08:25,466
Haga clic de nuevo. Aquí está la tienda de identificación es nula. Entonces comenzamos a conseguir ...

138
00:08:26,333 --> 00:08:29,466
ventana equivocada. Entonces verá que tenemos algunas ... bueno, en primer

139
00:08:29,483 --> 00:08:32,466
lugar, vamos a ver esto. Tenemos 711 filas.

140
00:08:33,216 --> 00:08:35,466
Así que si nos encontramos con esto de nuevo,

141
00:08:36,483 --> 00:08:38,466
y permite que se puede eliminar este temporal,

142
00:08:40,483 --> 00:08:42,466
y luego se corre esta misma declaración

143
00:08:44,300 --> 00:08:47,466
y lo volvemos. Ahora tenemos 19.820 filas. Esa es la idea de

144
00:08:47,483 --> 00:08:50,466
eliminar los duplicados que discutimos hace un poco.

145
00:08:51,483 --> 00:08:55,466
Por lo que podemos hacer eso. Estos son los alias. Ya hemos visto

146
00:08:55,483 --> 00:08:59,0
esto en acción, por lo que no se preocupe de éstos demasiado.

147
00:08:59,483 --> 00:09:03,466
Vamos a seguir adelante y echar un vistazo a esta es que la instrucción CASE.

148
00:09:03,483 --> 00:09:05,466
Quiero mostrarles que realmente en acción. Así que voy a

149
00:09:05,483 --> 00:09:08,466
seguir adelante y ejecutar este. Ya que hemos caminado a través y

150
00:09:08,483 --> 00:09:12,366
hablamos de ello, por lo que tendremos que ejecutar ahora, y que veremos ahora

151
00:09:12,450 --> 00:09:16,466
que tenemos ProductID, tenemos Name, ProductSubCategoryID,

152
00:09:16,483 --> 00:09:19,466
así que eso es una incógnita. Si me desplazo hacia abajo, recuerde, estamos buscando

153
00:09:19,483 --> 00:09:24,466
para Win 1, por lo que si me desplazo hasta aquí, podríamos tener varios artículos aquí.

154
00:09:24,483 --> 00:09:28,466
Vas a ver ahora, cuando veo número uno, nos estamos bebidas que se exponen.

155
00:09:29,483 --> 00:09:32,466
Todo lo demás, de dos en dos, de tres en tres a través de cualquier otro número,

156
00:09:32,483 --> 00:09:36,200
sin valores van a mostrar Categoría Desconocida. Por lo tanto, nos permite

157
00:09:36,283 --> 00:09:39,466
controlar lo que realmente se muestra aquí cuando estamos en realidad

158
00:09:39,483 --> 00:09:43,466
estamos realizando o de ejecutar una instrucción CASE. Podemos controlar lo que se

159
00:09:44,0 --> 00:09:45,466
muestra en esa columna.

160
00:09:45,483 --> 00:09:48,466
>> Y es importante saber que la sentencia CASE, no es

161
00:09:48,483 --> 00:09:51,466
una declaración, es una expresión. Es una función, por lo que se puede

162
00:09:51,483 --> 00:09:56,466
utilizar en cualquier declaración, más o menos. Se puede utilizar en la actualización,

163
00:09:56,483 --> 00:09:59,466
establezca algo es igual al caso de que algo o en la cláusula ORDER BY

164
00:09:59,483 --> 00:10:04,400
o en la cláusula GROUP BY o en la cláusula ON, o lo que sea.

165
00:10:04,483 --> 00:10:07,466
Así que donde quiera se puede ejecutar una función, puede demandar la expresión CASE.

166
00:10:08,483 --> 00:10:12,466
>> JOINs. Las combinaciones se alcance, tal vez un poco confuso a veces.

167
00:10:12,483 --> 00:10:14,466
Vamos a seguir hablando de JOINs.

168
00:10:15,316 --> 00:10:18,266
y en los JOINs, tenemos diferentes formas de JOINs.

169
00:10:18,350 --> 00:10:22,466
Tenemos CROSS JOINs, INNER JOINs y OUTER JOINs, y puede ser

170
00:10:22,483 --> 00:10:25,466
un poco abrumador, pero sólo como una introducción, CROSS

171
00:10:25,183 --> 00:10:30,333
JOINs combina todas las tiradas de ambas tablas, a veces crea lo que se

172
00:10:30,416 --> 00:10:34,466
llama un producto cartesiano. Los INNER JOINs proporciona filtro para que coincidan

173
00:10:34,483 --> 00:10:39,466
las filas en las tablas, y luego los OUTER JOINs muestran todas

174
00:10:39,483 --> 00:10:43,466
las filas de una tabla determinada y después de que coincide filas de los

175
00:10:43,483 --> 00:10:46,466
otros contenidos están recuperados.

176
00:10:46,483 --> 00:10:50,466
Asi INNER JOINs, como ahora hemos introducido, son sólo unas filas en las que
177
00:10:50,483 --> 00:10:55,466
un partido se encuentra en ambas tablas. Un ejemplo de esto es como el que vamos a empezar

178
00:10:55,483 --> 00:10:59,166
desde el fondo ... así que menciona la idea de tener un alias,

179
00:10:59,250 --> 00:11:02,466
así que voy a sólo saltar hasta aquí, donde tenemos FROM

180
00:11:02,200 --> 00:11:06,466
Sales.SalesOrderHeader AS SOH. Ahí es donde el SOH está viniendo.

181
00:11:06,483 --> 00:11:12,466
Y entonces JOINing a Sales.SalesOrderDetail AS SOD, y luego

182
00:11:12,483 --> 00:11:14,466
lo que vamos a hacer es que queremos devolver contenido. Estas primeras

183
00:11:14,483 --> 00:11:18,383
dos columnas son procedentes de la tabla de cabecera. Estas restantes

184
00:11:18,466 --> 00:11:21,466
tres columnas son procedentes de la tabla de detalles. Así que vamos

185
00:11:21,483 --> 00:11:25,466
Para hacer JOIN en las tablas basadas en la SalesOrderID. Tienen que tener

186
00:11:25,483 --> 00:11:29,400
esa columna común. Vamos a hacer JOIN en las tablas de SalesOrderID,

187
00:11:29,483 --> 00:11:33,166
y eso va a devolver el contenido o columnas individuales

188
00:11:33,483 --> 00:11:34,466
de estos dos tablas

189
00:11:36,483 --> 00:11:37,466
en el mismo conjunto de resultados.

190
00:11:38,483 --> 00:11:42,233
>> Y, como se puede ver en donde, se dice JOIN en lugar de INNER JOIN,

191
00:11:42,316 --> 00:11:45,466
y INNER JOIN es el valor predeterminado. Así que si usted acaba de decir JOIN,

192
00:11:45,483 --> 00:11:49,466
y hacer un INNER JOIN. La otra cosa es, es la cláusula ON

193
00:11:49,483 --> 00:11:51,466
la segunda cláusula de filtro.

194
00:11:52,483 --> 00:11:56,466
Lo siento, es la cláusula de filtro. Asi que WHERE sucede, ON sucede, logicamente.

195
00:11:57,366 --> 00:12:00,466

Y la cláusula ON es igual que la cláusula WHERE. Se puede poner

196
00:12:00,483 --> 00:12:03,466
básicamente cualquier predicado en eso. No tiene que ser JOINed

197
00:12:03,483 --> 00:12:06,466
en la clave principal real, relación de clave externa. Podria

198
00:12:06,483 --> 00:12:11,450
ser JOIN en esta función de esta columna como algo.

199
00:12:12,300 --> 00:12:16,466
Eso es lo que puso en su lugar. Obviamente, los resultados pueden no

200
00:12:16,483 --> 00:12:20,466
ser lo que estás esperando, sino que se reúnen en realidad bastante frecuencia

201
00:12:20,483 --> 00:12:24,466
que puede tener un montón de beneficios de unirse a ... o responder interesantes

202
00:12:24,483 --> 00:12:29,466
ddatos cuando en realidad estás que no se incorporan en

203
00:12:29,483 --> 00:12:31,466
las llaves primarias, relaciones de llaves foranéas.

204
00:12:31,483 --> 00:12:34,183
>> ¿Cuál es la diferencia entre un INNER JOIN y un OUTER JOIN?

205
00:12:34,483 --> 00:12:39,466
>> El INNER JOIN, se obtiene sólo a través de las combinaciones reales

206
00:12:39,483 --> 00:12:45,233
a través de la tabla o las tablas involucradas, así que lo que puede ver

207
00:12:45,316 --> 00:12:49,466
en ello, lógicamente es, se toman dos tablas y se obtiene el conjunto masivo

208
00:12:49,483 --> 00:12:53,466
de todas las filas combinadas con todas las otras filas, y entonces aplicar

209
00:12:53,483 --> 00:12:55,466
el filtro en la cláusula ON.

210
00:12:56,316 --> 00:12:59,466

Obviamente, si se aplica esto, se dice que este ID es igual al ID,

211
00:12:59,483 --> 00:13:03,466
que sólo devolverá lo filas en realidad están emparejando a través

212
00:13:04,333 --> 00:13:09,466
de estas dos tablas. Entonces, ¿qué si, como un ejemplo que será, bueno, Brian,

213
00:13:09,483 --> 00:13:14,183
por favor, dame todos los clientes y sus pedidos, por lo que probablemente

214
00:13:14,266 --> 00:13:19,466
se hace un JOIN de la tabla clientes a la tabla de ordenes para el ID del cliente.

215
00:13:20,483 --> 00:13:24,433
Si cambio la pregunta un poco, y esta es una buena manera también

216
00:13:24,483 --> 00:13:27,466
de la clase de la práctica de SQL está traduciendo en realidad una pregunta

217
00:13:27,483 --> 00:13:35,166
en Inglés o, preferiblemente, de Suecia, de donde soy, a SQL.

218
00:13:35,250 --> 00:13:38,466
Así que si en lugar de decir, oye, ¿puedes por favor, dame la lista de.

219
00:13:38,483 --> 00:13:42,466
todos los clientes y sus pedidos? y también incluyen a los clientes que

220
00:13:42,483 --> 00:13:46,366
no tienen ninguna orden, porque los que no serán devueltas si uso

221
00:13:46,450 --> 00:13:50,466
este INNER JOIN. Así que el que lo haría en su lugar, si digo de los clientes,

222
00:13:51,300 --> 00:13:56,466
JOIN pedidos, diría LEFT JOIN, por lo LEFT OUTER JOIN, que

223
00:13:56,483 --> 00:14:00,466
es mantener las filas que no se pongan en venta de la tabla de la izquierda, para que

224
00:14:00,483 --> 00:14:03,466
los clientes se dice en primer lugar. Esa sería la tabla de la izquierda, y las ordenes

225
00:14:03,483 --> 00:14:06,466
sería la tabla de la derecha. Así que hemos combinación izquierda, evitar que la

226
00:14:06,483 --> 00:14:08,466
tabla de la izquierda, derecha JOIN es simplemente evitar que el cuadro de la derecha, y

227
00:14:09,333 --> 00:14:12,466
FULL JOIN también se incluyen órdenes que no tienen un cliente coincidentes.

228
00:14:12,483 --> 00:14:15,466
Eso suena como un problema de integridad referencial en este caso,

229
00:14:15,483 --> 00:14:18,466
pero eso es básicamente los OUTER JOINs.

230
00:14:18,483 --> 00:14:22,466
>> Muy bien, excelente. Y este es un ejemplo de cómo un LEFT OUTER

231
00:14:22,200 --> 00:14:26,216
JOIN ya que se acaba de describir se escribiría. Así que estamos buscando

232
00:14:26,300 --> 00:14:28,466
a los clientes que no hacen pedidos en este caso aquí, por lo que esto

233
00:14:28,483 --> 00:14:32,466
es un ejemplo de ese comando que acaba de Tobias en realidad nos explicó

234
00:14:32,483 --> 00:14:34,466
CROSS JOINs.

235
00:14:35,483 --> 00:14:38,400
CROSS JOINs combinar cada rol de la primera tabla con cada

236
00:14:38,483 --> 00:14:40,466
la fila de la segunda tabla. ¿Que nos da eso?

237
00:14:43,483 --> 00:14:46,400
Estamos combinando todas las filas de una tabla a la otra mesa.

238
00:14:46,483 --> 00:14:47,466
¿Por qué debería utilizar un CROSS JOIN?

239
00:14:48,483 --> 00:14:54,366
>> Bueno, no es todo lo que muchas razones. Se podría imaginar ...

240
00:14:54,483 --> 00:15:00,466
así que una cosa es, obviamente, sólo la generación de datos de prueba, es muy

241
00:15:00,216 --> 00:15:02,466
práctico, ya que se toma una tabla con 10 filas, CROSS JOIN

242
00:15:02,483 --> 00:15:06,466
con otra tabla con 10 filas, se obtiene 100 filas más atrás. Pero

243
00:15:06,483 --> 00:15:08,466
en realidad se podría tener un ejemplo interesante, como usted tiene una

244
00:15:09,166 --> 00:15:12,466
tabla de monedas con todas las monedas y CROSS JOIN

245
00:15:12,483 --> 00:15:15,216
que con ella misma, ya que usted consigue el producto de todas las combinaciones

246
00:15:15,300 --> 00:15:16,333
de monedas.

247
00:15:18,483 --> 00:15:22,466
>> Muy bien, así que no se utiliza en gran medida es lo que he oído, pero es bueno

248
00:15:22,483 --> 00:15:23,466
tenerlo por ahí.

249
00:15:24,450 --> 00:15:25,466
Así que ahora tenemos un SELF JOIN.

250
00:15:26,483 --> 00:15:29,200
El SELF JOIN, compara las filas de la misma tabla a la otra.

251
00:15:29,283 --> 00:15:30,466
¿Tengo un ejemplo de esto?.

252
00:15:30,483 --> 00:15:33,466
>> Pues bien, el ejemplo de divisas que di fue un ejemplo de un SELF

253
00:15:33,483 --> 00:15:35,466
JOIN, con un CROSS JOIN.

254
00:15:35,483 --> 00:15:38,466
>> Con un CROSS JOIN. Para que pueda tener SELF JOIN con CROSS JOIN.

255
00:15:38,483 --> 00:15:41,466
>> Si. SELF JOIN es sólo si se usa JOIN con uno mismo.

256
00:15:41,483 --> 00:15:44,466
>> ¿Cuáles son los más utilizados? Yo diría que el INNER

257
00:15:44,166 --> 00:15:46,466
JOIN, porque esa es la forma predeterminada. Si sólo tiene que teclear el JOIN,

258
00:15:46,166 --> 00:15:49,466
se obtiene el INNER, y luego LEFT y RIGHT OUTER JOINs, lo más probable.

259
00:15:49,483 --> 00:15:50,466
>> Si, absolutamente.

260
00:15:50,483 --> 00:15:54,466
>> Entonces, su SELF JOIN y su CROSS JOIN, son opciones,

261
00:15:54,483 --> 00:15:58,466
pero probablemente no se utiliza en gran medida. Tenemos, como se puede ver aquí,

262
00:15:58,483 --> 00:16:02,466
ejemplos disposición para la forma en que se escriben, pero

263
00:16:03,483 --> 00:16:07,466
sólo para la clase de darle algunas ideas sobre cómo iban a ser utilizados.

264
00:16:07,483 --> 00:16:09,466
>> Sí. Es, definitivamente, en el orden del INNER JOINs Y LUEGO LEFT

265
00:16:09,483 --> 00:16:11,466
JOINs y luego FULL JOINs.

266
00:16:11,483 --> 00:16:14,466
>> Vamos a echar un vistazo a algunos de ellos, si podemos conseguir sólo

267
00:16:14,483 --> 00:16:19,466
un par de ellos para ejecutar. Una vez más, he salvado todo el

268
00:16:19,483 --> 00:16:23,466
dolor de cabeza de mí en grasa los dedos y tratando de escribir todo esto.

269
00:16:23,483 --> 00:16:26,466
Se trata de que la declaración que he creado anteriormente, que te mostré

270
00:16:26,483 --> 00:16:27,466
antes, debería decir.

271
00:16:29,483 --> 00:16:33,200
Tratando de conseguir que se deslice hacia abajo. Aquí vamos. Así que este es el

272
00:16:33,283 --> 00:16:36,466
que yo había escrito antes, o se señaló anteriormente, por lo que esto

273
00:16:36,483 --> 00:16:40,466
es muestra de que INNER JOIN, y como Tobias señaló, no hacer

274
00:16:40,483 --> 00:16:43,366
INNER JOIN alli. Yo podría hacerlo un poco más claro

275
00:16:43,450 --> 00:16:47,466
poniéndolo como INNER JOIN, para que pueda ver exactamente el tipo de

276
00:16:47,483 --> 00:16:50,466
JOIN que es, pero es el valor predeterminado. Así que vamos a seguir adelante

277
00:16:50,483 --> 00:16:51,466
y ejecutar este.

278
00:16:52,483 --> 00:16:55,466
Y note que tenemos nuestro SalesOrderID. Recuerde, eso viene

279
00:16:55,483 --> 00:16:59,466
de la SOH, que es la cabecera de la orden. Tenemos la OrderDate.

280
00:16:59,483 --> 00:17:03,466
Eso también es viniendo de la mesa cabecera de la orden. Y luego

281
00:17:03,483 --> 00:17:04,466
tenemos tres columnasSOD

282
00:17:05,483 --> 00:17:08,466
que volveremos. Estos son procedentes de la SalesOrderDetail,

283
00:17:08,483 --> 00:17:12,466
de ProductID, UnitPrice y OrderQty. Estos están siendo devueltos

284
00:17:13,483 --> 00:17:16,466
a partir de los datos. Así que es una buena manera de tomar el contenido que reside

285
00:17:16,483 --> 00:17:21,383
en dos tablas diferentes. Nos unen a ellos en SalesOrderID ... en este

286
00:17:21,466 --> 00:17:25,466
caso aquí, 43659, y los resultados de dos tablas diferentes

287
00:17:25,483 --> 00:17:27,350
en un conjunto de resultados.

288
00:17:28,450 --> 00:17:30,466
Por eso es bueno que somos capaces de hacer eso, porque a menudo, cuando estamos

289
00:17:30,483 --> 00:17:32,466
estamos trabajando con bases de datos relacionales, que vamos a tener

290
00:17:32,483 --> 00:17:35,383
contenido varias tablas, y vamos a querer volver tal vez

291
00:17:35,466 --> 00:17:39,0
ese contenido en un único conjunto de resultados, y el uso de JOINs le

292
00:17:39,483 --> 00:17:42,466
ayudara a realizar eso. He aquí un ejemplo más que vamos a hacer con

293
00:17:42,483 --> 00:17:46,466
un JOIN, y esta es LEFT OUTER JOIN aqui, y el LEFT OUTER

294
00:17:47,0 --> 00:17:49,466
JOIN se va a devolver todos los clientes ... Sólo hasta eso.

295
00:17:50,483 --> 00:17:53,466
¿Dónde está mi deshacer en esta cosa? Deshacer me salva. Aquí vamos.

296
00:17:56,483 --> 00:17:59,466
Así que aquí está un ejemplo de un LEFT OUTER JOIN. Una vez más, vimos este

297
00:17:59,483 --> 00:18:04,466
en la diapositiva, pero tenemos Identificación de Cliente y StoreID, SalesOrderID

298
00:18:04,483 --> 00:18:08,466
y OrderDate. Y se puede ver aquí que CUST.StoreID,

299
00:18:10,483 --> 00:18:16,466
éstos están llegando de la tabla de orden, y luego la palabra, que

300
00:18:16,483 --> 00:18:20,466
is the SalesOrder header, is the SalesOrderID. So we're grabbing

301
00:18:20,483 --> 00:18:24,466
es la cabecera de órdenes de venta, es SalesOrderID. Así que estamos agarrando

302
00:18:25,483 --> 00:18:29,466
y estamos añadiendo contenido adicional de la declaración de la derecha.

303
00:18:29,166 --> 00:18:33,466
Por lo que sólo un ejemplo rápido sólo para mostrar que los que se ejecutan y

304
00:18:33,483 --> 00:18:36,433
que cuando les estamos mostrando, por lo que sólo quiere que le muestre cómo

305
00:18:36,483 --> 00:18:40,466
un JOIN a los que realmente funciona para usted cuando estamos ejecutando los JOINs.

306
00:18:42,483 --> 00:18:46,466
Muy bien, así que esas son formas de recuperación de contenidos desde el interior

307
00:18:46,200 --> 00:18:50,466
de SQL Server desde diferentes filas o tablas diferentes, si se quiere.

308
00:18:50,483 --> 00:18:54,466
También tenemos un montón de maneras que queremos filtrar y ordenar los datos,

309
00:18:54,483 --> 00:18:58,216
y usamos la cláusula ORDER BY, y lo hice brevemente una demostración de esto ya.

310
00:18:58,300 --> 00:19:00,466
El ORDER BY simplemente ordena las filas,

311
00:19:01,483 --> 00:19:05,466
y es sólo una manera de hacer la presentación de los contenidos más fácil

312
00:19:05,483 --> 00:19:08,466
para usted. Quieres ser capaz de ver SalesOrderID.

313
00:19:09,483 --> 00:19:15,466
Queremos que el fin, y como un entero. Tal vez usted quiere cliente

314
00:19:15,483 --> 00:19:18,433
por apellido, que desea ordenar alfabéticamente. Tal vez usted

315
00:19:18,483 --> 00:19:21,466
quiere fecha de la orden. Queremos saber el orden más reciente o la

316
00:19:21,483 --> 00:19:27,466
Para que entró en el pasado. Estos son ejemplos de apartaderos orden.

317
00:19:27,483 --> 00:19:30,166
Así que estamos haciendo un SELECT SalesOrderID, CustomerID y OrderDate

318
00:19:30,250 --> 00:19:33,466
del SalesOrderHeader, y van a ser ordenados por OrderDate,

319
00:19:33,483 --> 00:19:38,466
por lo que vamos a darnos tres columnas, SalesOrderID, CustomerID

320
00:19:38,483 --> 00:19:41,466
y OrderDate, y vamos a ordenar cronológicamente, que

321
00:19:41,483 --> 00:19:44,183
creo que es lo correcto, por OrderDate.

322
00:19:44,483 --> 00:19:47,466
También pudimos entrar y hacer un SELECT SalesOrderID, CustomerID.

323
00:19:47,483 --> 00:19:50,433
Ahora estamos reuniendo el año, y vamos a crear una columna,

324
00:19:50,483 --> 00:19:55,416
el YEAR de la OrderDate, AS OrderYear, de nuevo desde el SalesOrderHeader,

325
00:19:55,483 --> 00:19:59,466
y vamos al ORDER BY OrderYear. Este es un aliases creado

326
00:19:59,483 --> 00:20:01,466
porque estamos agarrando sólo el año desde la OrderDate.

327
00:20:01,483 --> 00:20:04,466
No estamos preocupados por la hora o la fecha.

328
00:20:04,483 --> 00:20:07,466
>> Así que aquí es que hay algo que es importante mencionar que

329
00:20:07,483 --> 00:20:12,466
muchas personas suelen pedir. Por lo tanto se puede decir AS OrderYear y luego

330
00:20:12,483 --> 00:20:17,466
ORDER BY este alias OrderYear, pero no se puede hacer como OrderYear

331
00:20:17,483 --> 00:20:20,466
y luego en la cláusula WHERE decir WHERE OrderYear es igual a

332
00:20:20,483 --> 00:20:23,466
algo, y eso tiene que ver con esta lógica de procesamiento de consultas

333
00:20:23,483 --> 00:20:26,466
lógico que hemos hablado antes, porque ORDER BY es lo único

334
00:20:26,483 --> 00:20:31,416
esto sucede después de SELECT. Así que cuando ORDER BY sucede, sabemos

335
00:20:31,483 --> 00:20:34,466
lo que los alias de columna son, pero cuando WHERE sucede, que no lo hacen

336
00:20:34,483 --> 00:20:36,466
saber, porque SELECT no ha sucedido todavía.

337
00:20:36,483 --> 00:20:38,466
>> Gran punto. Definitivamente gran punto. Y lo más interesante es,

338
00:20:38,483 --> 00:20:40,466
que podemos revertir esto. Tenemos la misma ...

339
00:20:42,483 --> 00:20:45,466
el ejemplo arriba es aquí Fecha de pedido. Podríamos hacerlo en el orden inverso

340
00:20:45,483 --> 00:20:49,466
sólo mediante el uso de la cláusula descendente aquí abajo. Y eso

341
00:20:49,233 --> 00:20:52,466
nos da el mismo contenido, pero en orden inverso al de las fechas,

342
00:20:53,0 --> 00:20:56,466
así que en vez de la más reciente ... o en lugar de los primeros

343
00:20:56,483 --> 00:21:00,466
uno, tendremos la más reciente en la parte superior. Vamos a filtrar datos usando

344
00:21:00,183 --> 00:21:02,466
la cláusula WHERE. Esa es una forma en que lo hacemos. Hemos visto

345
00:21:02,483 --> 00:21:05,466
un ejemplo de ello, donde habíamos todas las filas para estar en las.

346
00:21:05,483 --> 00:21:08,466
Un poco abrumadora. Así que lo que tenemos aquí es que tenemos

347
00:21:08,483 --> 00:21:12,466
CustomerID, TerritoryID de la Sales.Customer. Si acabo de dejar de

348
00:21:12,483 --> 00:21:15,466
allí y no tienen una cláusula WHERE, cada fila va a ser devuelto

349
00:21:15,183 --> 00:21:17,466
de la tabla Customers. Bueno, vamos a escribir WHERE TerritoryID

350
00:21:17,483 --> 00:21:21,433
= 6, por lo que quieren saber donde todos los clientes son que pertenecen

351
00:21:21,483 --> 00:21:24,466
en el TerritoryID = 6, o que no tenga que usar el mismo valor. yo podría decir

352
00:21:24,483 --> 00:21:29,350
WHERE TerritoryID = 6. Así que ahora quiero que todos los clientes en los territorios

353
00:21:29,433 --> 00:21:32,466
siete a cualquier número que pasa a través. También pudimos

354
00:21:32,483 --> 00:21:35,266
mezclar algunas de estas arriba. En la parte inferior, hablamos acerca de WHERE

355
00:21:35,350 --> 00:21:37,466
StoreID >= 1000 Y StoreID <= 1200.

356
00:21:40,483 --> 00:21:43,466
Así que quiero todo lo que el estratificados ... ahora, me he trasladado

357
00:21:43,483 --> 00:21:48,466
lejos del TerritoryID. El StoreID es 1000 o más alto, pero no más alto

358
00:21:48,483 --> 00:21:54,466
que 1200, así que tenemos esa pequeña zona de discontinuidad o rango que nosotros

359
00:21:54,483 --> 00:21:57,466
quiera que StoreID o el contenido para que StoreID de ser devueltos con.

360
00:21:57,483 --> 00:22:00,466
Así que de nuevo, es el control de lo que está sucediendo en un conjunto de resultados y

361
00:22:01,166 --> 00:22:02,466
la forma en que el contenido se visualiza en su caso.

362
00:22:04,166 --> 00:22:06,466
Otras formas en las que pueden filtrar los datos. Tal vez quiero más controles.

363
00:22:06,483 --> 00:22:11,466
No quiero ver cada elemento. Tal vez tengo 100.000 o 500.000

364
00:22:11,483 --> 00:22:15,466
filas, y quiero que sólo una parte de esas filas. Pero lo que podamos

365
00:22:15,483 --> 00:22:20,333
hacemos aquí es utilizar lo que se llama la opción TOP SELECT, y especificamos

366
00:22:20,483 --> 00:22:23,466
el número de elementos que se quieren ver. Si hago esto SELECT

367
00:22:23,483 --> 00:22:26,466
SalesOrderID, CustomerID, desde el SalesOrderHeader, y lo hizo

368
00:22:26,483 --> 00:22:31,466
ORDER BY DESC TotalDue, que podría conseguir 20.000 registros. No lo sé.

369
00:22:31,483 --> 00:22:34,216
Pero lo que estoy diciendo aquí es sólo dame la parte superior 20.

370
00:22:34,483 --> 00:22:37,466
Así que en este TOP SELECT (20), por ejemplo, yo no lo 100.000 registros.

371
00:22:37,483 --> 00:22:40,466
Quiero 20 fichas o cualquier número que puse ahí, por lo que podía

372
00:22:40,483 --> 00:22:43,416
cambiar eso a 50 y obtener los 50 primeros registros. Ahora, la cosa

373
00:22:43,483 --> 00:22:46,466
con lo que es, si tengo 100.000 o 200.000 registros y estoy tratando

374
00:22:46,483 --> 00:22:51,466
hacer este TOP SELECT (20), lo que si tuviera 15 y hay ocho

375
00:22:51,483 --> 00:22:55,466
más que partido, que son exactamente idénticos. Lo que esto va

376
00:22:55,483 --> 00:22:57,466
hacer es SELECT TOP (20) WITH TIES.

377
00:22:58,316 --> 00:23:01,466
Ahora, en vez de mostrar sólo 20 años, si llega al 20, si hay

378
00:23:01,483 --> 00:23:04,466
pasa a ser 23 porque tenemos algunos lazos, que va a mostrar

379
00:23:04,483 --> 00:23:07,466
encontrado 23 artículos, ya que no quiere que le muestre 20. digamos,

380
00:23:07,483 --> 00:23:11,466
por ejemplo, tenemos un vendedor, y el 20 mejores vendedores

381
00:23:11,483 --> 00:23:13,466
en las ventas de obtener un bono.

382
00:23:13,483 --> 00:23:17,466
Bueno, si yo acabo de hacer un SELECT TOP (20) y había 25 personas

383
00:23:17,483 --> 00:23:21,300
o 23 personas que tenían las ventas superiores pero no puso a los WITH

384
00:23:21,383 --> 00:23:24,466
TIES, hay tres personas que no van a conseguir que la bonificación.

385
00:23:25,0 --> 00:23:26,466
Hay tres personas que van a estar molesto conmigo y con el

386
00:23:26,483 --> 00:23:27,466
forma en que escribió el código.

387
00:23:28,283 --> 00:23:32,300
Así que podemos tener cuidado con eso. Podemos evitar la información

388
00:23:32,383 --> 00:23:36,466
ser ignorado o no se muestran mediante el uso de la opción WITH TIES.

389
00:23:36,483 --> 00:23:39,466
Podríamos ir a un porcentaje. Tengo 20.000 filas. En lugar de

390
00:23:39,483 --> 00:23:43,466
va siendo devuelto un número finito de filas, podríamos hacer

391
00:23:44,166 --> 00:23:47,466
un porcentaje de artículos que se devuelvan. Así que si tengo 20.000

392
00:23:47,483 --> 00:23:52,466
artículos, voy a conseguir 20 artículos. No me mantenga en las matemáticas, por lo que vamos

393
00:23:52,483 --> 00:23:53,466
tiene que ver en eso aquí.

394
00:23:53,483 --> 00:23:57,216
>> Por lo tanto voy a mostrar un poco de una demostración pensé en TOP, porque TOP

395
00:23:57,300 --> 00:23:58,466
es algo interesante.

396
00:23:59,483 --> 00:24:05,466
Así que si cambiamos a mi máquina de aquí, lo que me gustaría para mostrar

397
00:24:05,483 --> 00:24:09,466
es, en primer lugar, ya vimos TOP, de derecha? También tenemos el apoyo

398
00:24:09,483 --> 00:24:14,466
ahora en SQL Server 2012 para offset y la FETCH palabras clave, que

399
00:24:14,483 --> 00:24:18,466
La página de ayuda a través de los resultados, lo cual es muy común en las aplicaciones web.

400
00:24:18,483 --> 00:24:23,466
Así que digamos que solo voy a Production.Product y

401
00:24:24,483 --> 00:24:26,466
entonces digo ORDER BY,

402
00:24:28,483 --> 00:24:32,466
No sé, PrecioUnidad, es ListPrice? Aquí vamos, ListPrice.

403
00:24:32,483 --> 00:24:35,466
Ahora bien, esto me dará el resultado conjunto completo de nuevo. Lo que puedo

404
00:24:35,483 --> 00:24:40,466
Ahora ve a hacer es decir, bien, por favor OFFSET 10 filas

405
00:24:41,483 --> 00:24:43,466
y FETCH

406
00:24:45,483 --> 00:24:47,466
PRÓXIMOS 10, sólo las filas

407
00:24:49,483 --> 00:24:53,466
y que en realidad me dará las filas 11 a 20, y ahora

408
00:24:53,483 --> 00:24:59,466
Puedo ir y decir que vea el primero en llegar es plato, al parecer.

409
00:24:59,483 --> 00:25:04,466
Si voy y digo, bueno, PASE 20 filas, sigue siendo ...

410
00:25:06,483 --> 00:25:08,466
>> O desplazamiento al 20 filas.

411
00:25:10,483 --> 00:25:11,466
>> Oh, lo siento.

412
00:25:11,483 --> 00:25:14,266
Vamos a ver aquí.

413
00:25:15,483 --> 00:25:18,466
Ahora hay algo. Entonces, ¿qué está pasando aquí? Bueno, estos

414
00:25:18,483 --> 00:25:23,466
chicos todos tienen el mismo precio de lista, así que por accidente he mostrado

415
00:25:23,483 --> 00:25:25,466
un ejemplo aún mejor. Esto es increíble.

416
00: 25: 25,483 --> 00: 25: 26.283
>> Exactamente.

417
00:25:26,366 --> 00:25:32,450
>> Ah, lo buenos que somos, Brian. Esto es realmente bueno. Así que aquí estamos

418
00:25:32,483 --> 00:25:37,466
ver un problema que es común con básicamente la parte superior e OFFSET

419
00:25:37,483 --> 00:25:39,466
y FETCH, que es lo que sucede si no pedir por algo

420
00:25:40,0 --> 00:25:44,466
eso es único. Así que vamos a ir y añadir ProductID aquí, que será

421
00:25:44,483 --> 00:25:46,333
hacer que tenga un poco más de sentido.

422
00:25:46,483 --> 00:25:50,466
Ahora, bien, Tenedor Corona es aparentemente la fila superior, y entonces voy a

423
00:25:50,483 --> 00:25:51,466
y dirán, bueno, 40 ...

424
00:25:52,483 --> 00:25:56,0
Ahora estoy saltando hacia adelante. Y es obvio que se pueden utilizar variables

425
00:25:56,483 --> 00:26:02,233
y las expresiones, por lo que podrían decir aquí @ OFFSET como estoy pasando.

426
00:26:02,316 --> 00:26:04,466
Así que eso es una cosa que quería mostrar chicos, lo cual es interesante.

427
00:26:04,483 --> 00:26:08,166
La otra cosa, que es un poco especial y no hemos hablado

428
00:26:08,483 --> 00:26:11,466
Acerca de la unión, porque no lo tenemos todo en cualquiera de

429
00:26:11,483 --> 00:26:17,466
nuestras diapositivas, pero UNION es la combinación de conjuntos de resultados mediante la concatenación

430
00:26:17,483 --> 00:26:22,233
ellos en lugar de UNEN, lo que les está combinando horizontalmente.

431
00:26:22,316 --> 00:26:28,466
Así que tengo una consulta de ejemplo digamos que Brian me preguntó:

432
00:26:28,483 --> 00:26:33,466
hola, Tobias, puedo obtener los dos productos de negro más caras

433
00:26:33,483 --> 00:26:37,466
y los dos productos más caras rojas en una consulta. Y tu

434
00:26:37,483 --> 00:26:39,466
ir, está bien, que suena como una pregunta razonable, Brian.

435
00:26:39,483 --> 00:26:40,466
>> Para un Lamborghini.

436
00:26:41,483 --> 00:26:45,466
>> Sí, sí. Así que voy a ir, está bien, vamos a Nombre y

437
00:26:47,483 --> 00:26:49,466
ListPrice y color.

438
00:26:50,483 --> 00:26:53,466
Debe ser un producto bastante aburrida, ya que la única tienen un color,

439
00:26:53,483 --> 00:27:00,466
pero de todas maneras. Y yo quiero probablemente la parte superior de dos, a la derecha, y luego DONDE

440
00:27:00,483 --> 00:27:06,250
Color = "Negro" en este caso, y no sé si es realmente negro

441
00:27:06,333 --> 00:27:11,466
un color y la forma en que funciona, pero en todo caso. Y, obviamente PEDIDO

442
00:27:11,483 --> 00:27:16,233
POR es importante aquí. Usted dice ORDER BY DESC ListPrice, ya

443
00:27:16,316 --> 00:27:19,466
queremos que los productos más caros. Bueno, por lo que pasa a

444
00:27:19,483 --> 00:27:21,466
ser de esta montaña 100 Negro.

445
00:27:21,483 --> 00:27:23,466
>> Creo que es una bicicleta de montaña o algo así.

446
00:27:24,483 --> 00:27:25,466
>> Bueno, nunca se sabe.

447
00:27:25,483 --> 00:27:26,466
>> Nunca se sabe.

448
00:27:26,483 --> 00:27:30,466
>> Y el también quería el producto de color rojo, por lo que parecieron

449
00:27:30,183 --> 00:27:35,466
una consulta independiente, por lo que también me dan los dos productos más caras rojas.

450
00:27:36,0 --> 00:27:39,466
De acuerdo, no tenemos esos. Ahora bien, esta cláusula UNION será muy

451
00:27:39,483 --> 00:27:42,466
interesante, porque eso es, de nuevo, simplemente tomar estas sin

452
00:27:42,483 --> 00:27:47,466
conjuntos de resultados y rompiendo juntos, así que diga UNION ALL.

453
00:27:47,483 --> 00:27:51,466
Unión Europea es implícitamente un DISTINCT, por lo que pasará automáticamente

454
00:27:51,483 --> 00:27:55,466
y eliminar duplicados. Eso es por la norma, y ​​obviamente eso es ...

455
00:27:55,483 --> 00:27:58,466
si usted sabe que no hay duplicados entre los conjuntos, ¿por qué pagar

456
00:27:58,483 --> 00:28:01,466
el costo de hacerlo, por lo UNION ALL medios no eliminan duplicados.

457
00:28:01,483 --> 00:28:04,466
En realidad, la instrucción SELECT, se puede decir seleccionar todo, medios

458
00:28:04,483 --> 00:28:08,466
el mismo, pero nadie lo escribe. Así SELECT DISTINCT y en Seleccionar todo.

459
00:28:08,483 --> 00:28:11,466
Así que ahora, vemos que hay una serpenteante roja aquí, ¿verdad?

460
00:28:12,483 --> 00:28:16,400
Así que si intento esto, que comenzará a quejarse y decir, hey, Tobias,

461
00:28:16,483 --> 00:28:21.466
esto no tiene ningún sentido. Debido ORDER BY es en el nivel establecido.

462
00:28:21,483 --> 00:28:24,466
Es a nivel de conjunto de resultados, así que lo que vamos a volver realidad.

463
00:28:25,283 --> 00:28:26,466
Por lo que sabemos ...

464
00:28:28,483 --> 00:28:30,466
algo pasó en mi pantalla.

465
00:28:30,483 --> 00:28:32,466
Bien ahora

466
00:28:34,483 --> 00:28:35,466
que me ven, pero no de la pantalla.

467
00:28:35,483 --> 00:28:38,466
>> Estamos de vuelta a usted. ¿Hay que volver a la demo?

468
00:28:38,483 --> 00:28:40,466
>> Así que ahora se puede ver que me escribe.

469
00:28:41,216 --> 00:28:44,316
>> Haga de cuenta que está escribiendo las teclas que se estarían viendo.

470
00:28:45,266 --> 00:28:49,466
>> Maravilloso. Aquí vamos. Así, de nuevo, vimos que esto era los dos más

471
00:28:49,483 --> 00:28:54,466
caro negro y éstos eran los dos más caros, por lo que alrededor de 3000.

472
00:28:54,483 --> 00:28:57,466
Así que vamos a eliminar esta cláusula ORDER BY,

473
00:28:59,366 --> 00:29:01,466
y ahora obtenemos algo completamente diferente de nuevo. Y esto

474
00:29:02,483 --> 00:29:06,350
es debido a la lógica de procesamiento de la consulta, a la derecha, porque

475
00:29:06,433 --> 00:29:07,466
primero vamos y hacemos

476
00:29:08,483 --> 00:29:12,466
la cláusula FROM, la cláusula WHERE, por lo que tenemos todo el negro

477
00:29:12,483 --> 00:29:17,466
productos, y entonces tenemos sólo la parte superior dos primeros que encontramos.

478
00:29:17,483 --> 00:29:20,466
Y luego vamos y hacemos lo mismo con los productos rojo, la parte superior

479
00:29:20,483 --> 00:29:23,383
primero que nos encontramos, y luego se concatena los conjuntos de resultados y luego

480
00:29:23,466 --> 00:29:27,466
clasificamos el conjunto de resultados. Así que si a su vez en la ejecución de la consulta

481
00:29:27,483 --> 00:29:32,466
plan que podemos encontrar aquí, esto es algo que también las personas

482
00:29:32,483 --> 00:29:35,466
utilizar para optimizar básicamente sus consultas, pero también puede ser muy

483
00:29:35,483 --> 00:29:38,466
útil en realidad sólo entender lo que está pasando. Así que si yo

484
00:29:38,483 --> 00:29:41,466
mirar el plan de ejecución aquí, podemos ver, nos vamos al parecer,

485
00:29:41,483 --> 00:29:45,466
y escanear un índice aquí, que es la tabla, el índice agrupado.

486
00:29:45,483 --> 00:29:47,466
Entonces nosotros rematar inmediatamente.

487
00:29:48,183 --> 00:29:50,466
No hay clasificación que ocurre antes de eso. A continuación, se concatena

488
00:29:50,483 --> 00:29:54,466
el resultado se pone, y ahora nos vamos especie basada en el color.

489
00:29:55,483 --> 00:29:59,466
Así que lo que quiero hacer es, en lugar de esto, lo que no hay ...

490
00:29:59,483 --> 00:30:02,466
que no es un error en el producto, ¿verdad? Es sólo la forma en que

491
00:30:02,483 --> 00:30:06,333
el lenguaje funciona. En cambio que pueda hacer ... y esto obtendremos

492
00:30:06,416 --> 00:30:09,466
en más detalles más adelante, pero puedo hacer una tabla derivan aquí

493
00:30:09,483 --> 00:30:12,466
y decir, bueno, de esta cláusula SELECT.

494
00:30:13,483 --> 00:30:17,466
Ahora, no es ambigua más. Yo digo, bueno, agarra esta

495
00:30:17,483 --> 00:30:21,466
conjunto resultante. Ahora son los dos productos más caras negras, y

496
00:30:21,483 --> 00:30:23,466
a continuación, concatenar que con la

497
00:30:25,333 --> 00:30:28,466
dos productos más caras rojas.

498
00:30:28,483 --> 0030:32,233
Tenemos que tener alias aquí en las tablas aquí o en estos conjuntos.

499
00:30:33,483 --> 00:30:36,416
Y ahora vamos a obtener el resultado correcto. Y ahora que puedo, evidentemente,

500
00:30:36,483 --> 00:30:38,466
También añadir un ORDER BY aquí y digo, bueno, me gustaría

501
00:30:38,483 --> 00:30:44,183
ordenar por nombre. Así que ese conjunto de resultados, quiero esos cuatro filas ordenadas

502
00:30:44,266 --> 00:30:44,466
por nombre.

503
00:30:45,483 --> 00:30:48,466
Por lo que tenemos que volver, parece tener sentido, y ahora la ejecución

504
00:30:49,483 --> 00:30:51,466
plan, podemos ver que tenemos un operador diferente aquí, que es

505
00:30:51,483 --> 00:30:54,466
Ahora el operador de clase superior.

506
00:30:54,483 --> 00:30:57,333
A continuación, se concatena y luego clasificamos el conjunto de resultados.

507
00:30:57,416 --> 00:30:57,466
>> Niza.

508
00:30:57,483 --> 00:31:02,466
>> Así que aquí sólo podemos ver, qué hacer UNIÓN, que puede claramente

509
00:31:02,200 --> 00:31:07,466
sea ​​útil, y en realidad la forma TOP cruza con ORDER BY.

510
00:31:07,483 --> 00:31:09,466
>> Muy bien, excelente. Gran demostración. Muy bien, así que va

511
00:31:10,483 --> 00:31:13,466
para envolver el módulo dos aquí. Hablamos de la instrucción SELECT,

512
00:31:13,483 --> 00:31:16,466
introdujimos el claro, reduzca. No está implicado algo de sobrecarga,

513
00:31:16,483 --> 00:31:19,466
Tobias señaló a nosotros, acerca de la DISTINCT elimina los

514
00:31:19,483 --> 00:31:23,466
funciones redundantes. Introdujimos los dos alias de columna y de tabla.

515
00:31:23,483 --> 00:31:26,466
Hablamos de la sentencia CASE. Hablamos de los pocos

516
00:31:26,483 --> 00:31:28,466
diferentes tipos de combinaciones que vamos a estar cómodo

517
00:31:28,483 --> 00:31:32,266
o la necesidad de sentirse cómodo con el trabajo. En concreto, el valor predeterminado

518
00:31:32,350 --> 00:31:36,0
uno está en la unión interna, y tenemos la combinaciones externas. Nosotros vimos

519
00:31:36,483 --> 00:31:39,350
en el ORDER BY y la cláusula WHERE. Tuvimos una bonita demostración de

520
00: 31: 39,433 --> 00: 31: 43.466
Tobias en la cláusula UNION, y también hablaron sobre el TOP

521
00:31:43,483 --> 00:31:47,466
cláusula en esta zona, aquí. Así que vamos a seguir adelante y tomar a 10 minteu

522
00:31:47,483 --> 00:31:50,466
partimos, y lo que hacemos cuando volvamos, cuando volvamos, estamos

523
00:31:50,483 --> 00: 31:52,466
va a entrar en el siguiente módulo.

524
00:31:53,483 --> 00:31:56,466
Y cuando vamos al siguiente módulo, vamos a empezar a hablar

525
00:31:56,483 --> 00:31:59,466
sobre algunos temas ... de nuevo, más avanzadas adicionales cuando estamos

526
00:31:59,483 --> 00:32:05,250
buscando la manera para nosotros para consultar el contenido de SQL Server 2012.