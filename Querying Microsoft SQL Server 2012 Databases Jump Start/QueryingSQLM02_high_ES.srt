1
00:00:00,333 --> 00:00:06,333
[Música]

2
00:00:12,483 --> 00:00:20,466
>> Vamos a entrar en nuestro próximon módulo y avanzar a un nivel superior.

3
00:00:20,483 --> 00:00:23,466
Vamos a introducirnos en las instrucciones SELECT avanzadas,

4
00:00:24,483 --> 00:00:26,466
y en las instrucciones SELECT avanzadas, vamos a hablar

5
00:00:26,483 --> 00:00:29,466
aqui, a medida que avanzamos, iremos hablando acerca

6
00:00:29,483 --> 00:00:34,466
de cosas como la clausula DISTINCT, la aliases, la funcion scalar,

7
00:00:35,333 --> 00:00:39,466
uso de CASE, JOINS y MERGEs. Empezaremos con eso.

8
00:00:39,483 --> 00:00:44,383
Filtracion de datos, clasificacion de datos y como trabajamos con los valores nulos.

9
00:00:44,483 --> 00:00:46,466
Asi que aqui finalizamos con el primer modulo,

10
00:00:46,483 --> 00:00:49,466
y vamos a avanzar a un nivel superior e iniciar a trabajar

11
00:00:49,483 --> 00:00:53,466
con algunas de las opciones avanzadas que tenemos a nuestra disposición.

12
00:00:53,483 --> 00:00:55,250
Anteriormente dimos una pequeña introducción... hablamos acerca

13
00:00:55,333 --> 00:00:57,466
de la clasificación y el filtrado cuando se utiliza la cláusula WHERE,

14
00:00:57,483 --> 00:01:00,466
que no hizo mucho con JOINs, Peor ahora hablaremos

15
00:01:00,483 --> 00:01:03,466
de cláusulas mas avanzadas que podemos

16
00:01:03,483 --> 00:01:06,333
utilizar con la intrucción SELECT.

17
00:01:06,483 --> 00:01:09,466
Tobias, ¿Cómo me ayudará esta sentencia DISTINCT aqui?

18
00:01:10,0 --> 00:01:15,466
>> La sentencia DISTINCT se refiere a tolo lo relacionado a la eliminación de duplicados en un conjunto, y

19
00:01:16,483 --> 00:01:18,466
normalmente se utiliza por

20
00:01:19,483 --> 00:01:24,466
si deseas tener todos los primeros nombres de una tabla, y tiene

21
00:01:24,483 --> 00:01:27,466
bastantes Jonh y aun más Tobias, porque es obvio que es

22
00:01:27,483 --> 00:01:32,400
un nombre muy común. Y asi, si solo dices SELECT primer nombre

23
00:01:32,483 --> 00:01:36,466
de los empleados o lo que sea, simplemente le dara toda los

24
00:01:36,166 --> 00:01:38,466
nombres sin ningun orden en particular, pero si usted dice DISTINCT, se

25
00:01:38,483 --> 00:01:41,466
le dará la combinación única en todas las columnas, por lo que es

26
00:01:41,483 --> 00:01:45,466
algo importante que debemos recordar. DISTINCT ira a través de toda la fila.

27
00:01:45,483 --> 00:01:49,233
No se ve en una columna especifica. si no que es a través de

28
00:01:49,316 --> 00:01:52,466
toda la fila que va a proyectar, y luego

29
00:01:52,483 --> 00:01:58,466
da el resultado de nuevo sin los duplicados. Es importante

30
00:01:58,483 --> 00:02:03,466
conocer que DISTINCT es normalmente una declaracion bastante grande de

31
00:02:03,483 --> 00:02:07,466
mantener, por lo que cuanto mayor sea el conjunto, mas trabajo tendríamos que hacer para

32
00:02:07,483 --> 00:02:11,466
aprobar estos duplicados. Por lo general incluye clasificar el resultado

33
00:02:11,483 --> 00:02:14,466
primero y luego ir a través de la eliminacion y que, como era de esperarse

34
00:02:14,483 --> 00:02:17,466
si lo que se necesita para eliminar los duplicados de un conjunto,

35
00:02:17,233 --> 00:02:19,466
que tendría que hacer algo asi.

36
00:02:20,483 --> 00:02:25,466
>> Efectivamente. Y entonces aquí hay un ejemplo de la utilización de un StoreID SELECT DISTINCT .

37
00:02:25,483 --> 00:02:28,466
Así que si acabo de hacer un SELECT desde StoreID Sales.Customer, que va

38
00:02:28,483 --> 00:02:32,466
a mostrar múltiples ocurrencias de StoreID. Al arrojar la

39
00:02:32,483 --> 00:02:35,466
cláusula DISTINCT allí, ahora que va a mostrarme cada

40
00:02:35,183 --> 00:02:38,466
StoreID, o que va a mostrar que una vez, cada StoreID, que

41
00:02:38,483 --> 00:02:40,466
sea como usted dijo. Es un poco más arriba, pero

42
00:02:40,483 --> 00:02:43,466
mi conjunto de resultados va a tener uno mas pequeño.

43
00:02:43,483 --> 00:02:46,466
>> Y es importante, esto de rendimiento. Probablemente vamos a

44
00:02:46,483 --> 00:02:48,466
hablar un poco acerca de rendimiento a lo largo del día.

45
00:02:49,483 --> 00:02:53,250
Pero primero viene funcionalidad, ¿verdad? Primero tiene que obtener los

46
00:02:53,333 --> 00:02:55,466
resultados que usted está realmente interesado, y luego desea

47
00:02:55,483 --> 00:02:59,466
optimizar esto. Y, obviamente, en lo que respecta a los resultados,

48
00:02:59,483 --> 00:03:01,466
cuanto más se puede restringir y cuanto más se puede entender 

49
00:03:01,483 --> 00:03:06,200
exactamente lo que se necesita, probablemente, el más usted puede ajustar el rendimiento.

50
00:03:06,283 --> 00:03:09,250
Pero al final del día, no se puede utilizar una declaración general

51
00:03:09,333 --> 00:03:12,466
como nunca para uso distinto, porque si no desea que los duplicados

52
00:03:12,483 --> 00:03:15,466
de allí, es de suponer que se deben utilizar DISTINCT.

53
00:03:15,483 --> 00:03:17,466
>> Sí. Siempre y cuando se entienda la sobrecarga que implica, como ya

54
00:03:17,483 --> 00:03:19,466
dijimos, no van a haber momentos en los que vas a tener que

55
00:03:19,483 --> 00:03:23,466
usarlo, pero siempre y cuando usted entienda la sobrecarga que está involucrado

56
00:03:23,483 --> 00:03:26,466
con eso, vas a ser capaz de ejecutar con eso. He aquí algunos

57
00:03:26,483 --> 00:03:30,466
utilizando aliases. Aquellos ayuda tipo de formato. Una vez más, vamos

58
00:03:30,183 --> 00:03:33,466
a mirar las diferentes formas en las que podríamos controlar los resultados y

59
00:03:33,483 --> 00:03:36,466
nuestro conjunto de resultados, por lo que hemos llamando a los aliases de aquí, donde tenemos

60
00:03:36,483 --> 00:03:41,466
got seleccionar la cantidad SalesOrderID, UnitPrice, orden, como la cantidad.

61
00:03:41,483 --> 00:03:43,466
Así que esa es la forma en que se va a mostrar eso. Así que esto es mediante

62
00:03:43,483 --> 00:03:47,466
la adición de un aliases para una columna mediante el uso de la cláusula AS. Podemos

63
00:03:47,483 --> 00:03:52,466
hacer algo muy similar con sólo utilizar el nuevo editor de columnas.

64
00:03:52,483 --> 00:03:56,466
Ponemos Cantidad = OrderQty, por lo que echó por tipo de estos en todo

65
00:03:56,483 --> 00:03:59,466
sin la cláusula AS, por lo que la nueva cabecera de la columna está a la

66
00:03:59,483 --> 00:04:03,466
izquierda del signo igual, como lo es en comparación con el derecho de

67
00:04:03,483 --> 00:04:07,466
el AS. También puede aliases de columna accidentales. Me gusta este.

68
00:04:07,483 --> 00:04:12,316
Tenemos identificación de la orden de venta, el precio unitario y la cantidad de Sales.SalesOrderDetail.

69
00:04:12,483 --> 00:04:17,466
Notice I didn't put a comma after unit price, so this is why

70
00:04:17,483 --> 00:04:21,466
Note que no puse una coma después de precio por unidad, por lo que esta es la razón por

71
00:04:21,483 --> 00:04:26,466
la que me dan contenido que es el precio unitario con la cabecera de la cantidad.

72
00:04:26,483 --> 00:04:29,466
Es el orden correcto, ¿O voy a la inversa? No puedo recordar.

73
00:04:29,483 --> 00:04:30,466
Lo veremos.

74
00:04:31,483 --> 00:04:35,466
Porque hay contenidos allí sin la coma, es la identificación de

75
00:04:35,483 --> 00:04:38,183
cantidad como encabezado de la columna, pero va a mostrar en realidad

76
00:04:38,266 --> 00:04:39,466
UnitPrice alli.

77
00:04:40,483 --> 00:04:42,466
>> Así, con respecto a esto, usted puede preguntarse, ¿por qué tengo tres

78
00:04:43,333 --> 00:04:47,466
maneras diferentes de hacer la misma cosa? ¿Es justo que la gente se confunda?

79
00:04:48,483 --> 00:04:52,466
No. Entonces, básicamente, como es lo que debes usar. AS es lo que se

80
00:04:52,483 --> 00:04:57,466
define en el estándar ANSI SQL. Por eso apoyamos iguales y

81
00:04:57,483 --> 00:05:01,466
básicamente, sin hacer de forma adicional, así que eso es lo que se ve

82
00:05:02,166 --> 00:05:05,466
en la parte inferior existe, es debido a razones de herencia. Así que una de

83
00:05:05,483 --> 00:05:09,400
las cosas que hacemos muy bien en SQL Server es mantener la

84
00:05:09,483 --> 00:05:13,383
compatibilidad hacia atrás trabajando para usted. Así que, básicamente, si introducimos

85
00:05:13,466 --> 00:05:17,466
algo, aunque sea hace mucho, mucho tiempo, todavía se puede

86
00:05:19,183 --> 00:05:22,166
ejecutar el comando en la actualidad. La única vez que vamos y quitarlo es básicamente

87
00:05:22,250 --> 00:05:26,200
si causa problemas. Por lo que es muy aconsejable utilizar AS,

88
00:05:26,283 --> 00:05:29,466
ya que es la forma en ANSI SQL de escribirlo, pero estas otras

89
00:05:29,483 --> 00:05:30,466
maneras, también.

90
00:05:32,233 --> 00:05:35,466
>> Muy bien, la bondad de la idea de aliases se hace la columna

91
00:05:35,483 --> 00:05:37,466
de cabeceras un poco más manejable, porque a veces el que

92
00:05:37,483 --> 00:05:41,466
diseñó la base de datos no puede tener los títulos de las columnas más fácil de usar.

93
00:05:41,483 --> 00:05:44,466
Ahora podemos definir aquellos un poco diferente. Aliases para

94
00:05:44,483 --> 00:05:46,466
hacer referencia a las tablas, que vio cómo lo hicimos un poco antes.

95
00:05:46,483 --> 00:05:51,466
Tenemos SELECT SalesOrderID, ProductID, a partir de esta tabla Sales.SalesOrderDetail

96
00:05:52,333 --> 00:05:57,466
AS SalesOrders. Ahora puedo hacer referencia a esta tabla tiene órdenes de venta

97
00:05:57,483 --> 00:06:00,466
en futuras declaraciones aquí. Esto es un poco más para las columnas.

98
00:06:00,483 --> 00:06:03,466
Ahora es sin el AS, y luego tenemos los aliases de tabla en una

99
00:06:03,483 --> 00:06:08,466
cláusula SELECT, y eso es lo que hicimos antes, en mi demo anterior.

100
00:06:08,483 --> 00:06:12,466
Una vez defino, o si me identifico órdenes de venta hasta aquí con la

101
00:06:13,333 --> 00:06:16,466
cláusula AS, o si uso una cláusula AS, tengo que especificar que en

102
00:06:16,483 --> 00:06:21,466
la instrucción SELECT. Así que eso es sólo el uso de las tablas como

103
00:06:21,483 --> 00:06:22,466
un aliases.

104
00:06:22,483 --> 00:06:25,466
>> Así que ¿para qué usar estos alias de tabla?

105
00:06:25,483 --> 00:06:27,466
>> Bueno, si estás haciendo ... vamos a hablar de uniones.

106
00:06:27,483 --> 00:06:30,466
Si vas a ser capaz de hacer referencia, tal vez, una mesa o varias

107
00:06:30,483 --> 00:06:34,466
tablas o una tabla varias veces usando diferentes nombres, como

108
00:06:34,483 --> 00:06:37,466
dentro de una combinación, estos van a ser beneficioso cuando vemos la

109
00:06:37,483 --> 00:06:39,166
une a un poco más tarde.

110
00:06:39,483 --> 00:06:42,466
>> Sí, y también le ayudará de escribir demasiado. Si

111
00:06:42,483 --> 00:06:46,416
necesita hacer referencia a este nombre de la tabla todo el tiempo, que le ayudará

112
00:06:46,483 --> 00:06:48,466
si utiliza los alias y los hacen más cortos.

113
00:06:51,200 --> 00:06:53,466
>> Expresiones CASE. Una expresión CASE sencilla, vamos a hablar de ellos.

114
00:06:53,483 --> 00:06:58,433
Esto nos permite comparar un valor de una lista de posibles valores

115
00:06:58,483 --> 00:07:00,466
y luego realizar alguna ...

116
00:07:01,483 --> 00:07:05,466
una declaración sobre la base de los resultados de esa. Expresiones CASE

117
00:07:05,483 --> 00:07:09,466
se pueden utilizar en su columna de SELECT, donde tienen cláusulas ORDER BY.

118
00:07:09,483 --> 00:07:14,466
Y se muestra un ejemplo de estos aquí, donde tenemos

119
00:07:14,483 --> 00:07:15,466
SelectProductID, Name

120
00:07:17,250 --> 00:07:20,466
y ProductSubCategoryID, CASE ProductSubCategoryID, WHEN 1,

121
00:07:20,483 --> 00:07:23,466
entonces es igual a las bebidas. ELSE, es una categoría desconocida.

122
00:07:23,483 --> 00:07:26,466
Así que más o menos se va a ir hacia abajo a través, y cuando se encuentra

123
00:07:26,483 --> 00:07:30,433
que los ProductSubCategoryID es igual a 1, vamos a saber

124
00:07:30,483 --> 00:07:34,466
que es bebidas. De lo contrario, se va a mostrar como una categoría desconocida.

125
00:07:34,483 --> 00:07:37,416
Así que cuando hago una demo, te voy a mostrar este comando específicamente

126
00:07:37,483 --> 00:07:40,466
para que tenga una mejor idea aquí en cuanto a cómo se ve

127
00:07:40,183 --> 00:07:40,466
en acción.

128
00:07:43,416 --> 00:07:44,466
De hecho, vamos a hacer eso ahora.

129
00:07:46,400 --> 00:07:50,466
Entonces, ¿qué voy a hacer? es que voy a volver a mi imagen,

130
00:07:53,483 --> 00:07:54,466
y así

131
00:07:57,300 --> 00:08:01,350
voy a ir y voy a cargar una declaración hacia arriba, una consulta

132
00:08:02,366 --> 00:08:05,466
que ya había escrito. Ustedes no me quieren ver todo lo que eo

133
00:08:06,483 --> 00:08:08,466
dedo gordo, así que tengo algunas declaraciones aquí. Hablamos

134
00:08:08,483 --> 00:08:11,466
un poco sobre la DISTINCT aquí, así que sólo podemos correr muy

135
00:08:11,483 --> 00:08:15,466
rápido por lo que podemos ver que en la acción. Así SELECT DISTINCT StoreID.

136
00:08:15,483 --> 00:08:19,466
Permítanme aprovechar esta. Así que podemos ejecutar este de aquí.

137
00:08:22,483 --> 00:08:25,466
Haga clic de nuevo. Aquí está la tienda de identificación es nula. Entonces comenzamos a conseguir ...

138
00:08:26,333 --> 00:08:29,466
ventana equivocada. Entonces verá que tenemos algunas ... bueno, en primer

139
00:08:29,483 --> 00:08:32,466
lugar, vamos a ver esto. Tenemos 711 filas.

140
00:08:33,216 --> 00:08:35,466
Así que si nos encontramos con esto de nuevo,

141
00:08:36,483 --> 00:08:38,466
y permite que se puede eliminar este temporal,

142
00:08:40,483 --> 00:08:42,466
y luego se corre esta misma declaración

143
00:08:44,300 --> 00:08:47,466
y lo volvemos. Ahora tenemos 19.820 filas. Esa es la idea de

144
00:08:47,483 --> 00:08:50,466
eliminar los duplicados que discutimos hace un poco.

145
00:08:51,483 --> 00:08:55,466
Por lo que podemos hacer eso. Estos son los alias. Ya hemos visto

146
00:08:55,483 --> 00:08:59,0
esto en acción, por lo que no se preocupe de éstos demasiado.

147
00:08:59,483 --> 00:09:03,466
Vamos a seguir adelante y echar un vistazo a esta es que la instrucción CASE.

148
00:09:03,483 --> 00:09:05,466
Quiero mostrarles que realmente en acción. Así que voy a

149
00:09:05,483 --> 00:09:08,466
seguir adelante y ejecutar este. Ya que hemos caminado a través y

150
00:09:08,483 --> 00:09:12,366
hablamos de ello, por lo que tendremos que ejecutar ahora, y que veremos ahora

151
00:09:12,450 --> 00:09:16,466
que tenemos ProductID, tenemos Name, ProductSubCategoryID,

152
00:09:16,483 --> 00:09:19,466
así que eso es una incógnita. Si me desplazo hacia abajo, recuerde, estamos buscando

153
00:09:19,483 --> 00:09:24,466
para Win 1, por lo que si me desplazo hasta aquí, podríamos tener varios artículos aquí.

154
00:09:24,483 --> 00:09:28,466
Vas a ver ahora, cuando veo número uno, nos estamos bebidas que se exponen.

155
00:09:29,483 --> 00:09:32,466
Todo lo demás, de dos en dos, de tres en tres a través de cualquier otro número,

156
00:09:32,483 --> 00:09:36,200
sin valores van a mostrar Categoría Desconocida. Por lo tanto, nos permite

157
00:09:36,283 --> 00:09:39,466
controlar lo que realmente se muestra aquí cuando estamos en realidad

158
00:09:39,483 --> 00:09:43,466
estamos realizando o de ejecutar una instrucción CASE. Podemos controlar lo que se

159
00:09:44,0 --> 00:09:45,466
muestra en esa columna.

160
00:09:45,483 --> 00:09:48,466
>> Y es importante saber que la sentencia CASE, no es

161
00:09:48,483 --> 00:09:51,466
una declaración, es una expresión. Es una función, por lo que se puede

162
00:09:51,483 --> 00:09:56,466
utilizar en cualquier declaración, más o menos. Se puede utilizar en la actualización,

163
00:09:56,483 --> 00:09:59,466
establezca algo es igual al caso de que algo o en la cláusula ORDER BY

164
00:09:59,483 --> 00:10:04,400
o en la cláusula GROUP BY o en la cláusula ON, o lo que sea.

165
00:10:04,483 --> 00:10:07,466
Así que donde quiera se puede ejecutar una función, puede demandar la expresión CASE.

166
00:10:08,483 --> 00:10:12,466
>> JOINs. Las combinaciones se alcance, tal vez un poco confuso a veces.

167
00:10:12,483 --> 00:10:14,466
Vamos a seguir hablando de JOINs.

168
00:10:15,316 --> 00:10:18,266
y en los JOINs, tenemos diferentes formas de JOINs.

169
00:10:18,350 --> 00:10:22,466
Tenemos CROSS JOINs, INNER JOINs y OUTER JOINs, y puede ser

170
00:10:22,483 --> 00:10:25,466
un poco abrumador, pero sólo como una introducción, CROSS

171
00:10:25,183 --> 00:10:30,333
JOINs combina todas las tiradas de ambas tablas, a veces crea lo que se

172
00:10:30,416 --> 00:10:34,466
llama un producto cartesiano. Los INNER JOINs proporciona filtro para que coincidan

173
00:10:34,483 --> 00:10:39,466
las filas en las tablas, y luego los OUTER JOINs muestran todas

174
00:10:39,483 --> 00:10:43,466
las filas de una tabla determinada y después de que coincide filas de los

175
00:10:43,483 --> 00:10:46,466
otros contenidos están recuperados.

176
00:10:46,483 --> 00:10:50,466
Asi INNER JOINs, como ahora hemos introducido, son sólo unas filas en las que
177
00:10:50,483 --> 00:10:55,466
un partido se encuentra en ambas tablas. Un ejemplo de esto es como el que vamos a empezar

178
00:10:55,483 --> 00:10:59,166
desde el fondo ... así que menciona la idea de tener un alias,

179
00:10:59,250 --> 00:11:02,466
así que voy a sólo saltar hasta aquí, donde tenemos FROM

180
00:11:02,200 --> 00:11:06,466
Sales.SalesOrderHeader AS SOH. Ahí es donde el SOH está viniendo.

181
00:11:06,483 --> 00:11:12,466
Y entonces JOINing a Sales.SalesOrderDetail AS SOD, y luego

182
00:11:12,483 --> 00:11:14,466
lo que vamos a hacer es que queremos devolver contenido. Estas primeras

183
00:11:14,483 --> 00:11:18,383
dos columnas son procedentes de la tabla de cabecera. Estas restantes

184
00:11:18,466 --> 00:11:21,466
tres columnas son procedentes de la tabla de detalles. Así que vamos

185
00:11:21,483 --> 00:11:25,466
Para hacer JOIN en las tablas basadas en la SalesOrderID. Tienen que tener

186
00:11:25,483 --> 00:11:29,400
esa columna común. Vamos a hacer JOIN en las tablas de SalesOrderID,

187
00:11:29,483 --> 00:11:33,166
y eso va a devolver el contenido o columnas individuales

188
00:11:33,483 --> 00:11:34,466
de estos dos tablas

189
00:11:36,483 --> 00:11:37,466
en el mismo conjunto de resultados.

190
00:11:38,483 --> 00:11:42,233
>> Y, como se puede ver en donde, se dice JOIN en lugar de INNER JOIN,

191
00:11:42,316 --> 00:11:45,466
y INNER JOIN es el valor predeterminado. Así que si usted acaba de decir JOIN,

192
00:11:45,483 --> 00:11:49,466
y hacer un INNER JOIN. La otra cosa es, es la cláusula ON

193
00:11:49,483 --> 00:11:51,466
la segunda cláusula de filtro.

194
00:11:52,483 --> 00:11:56,466
Lo siento, es la cláusula de filtro. Asi que WHERE sucede, ON sucede, logicamente.

195
00:11:57,366 --> 00:12:00,466

Y la cláusula ON es igual que la cláusula WHERE. Se puede poner

196
00:12:00,483 --> 00:12:03,466
básicamente cualquier predicado en eso. No tiene que ser JOINed

197
00:12:03,483 --> 00:12:06,466
en la clave principal real, relación de clave externa. Podria

198
00:12:06,483 --> 00:12:11,450
ser JOIN en esta función de esta columna como algo.

199
00:12:12,300 --> 00:12:16,466
Eso es lo que puso en su lugar. Obviamente, los resultados pueden no

200
00:12:16,483 --> 00:12:20,466
ser lo que estás esperando, sino que se reúnen en realidad bastante frecuencia

201
00:12:20,483 --> 00:12:24,466
que puede tener un montón de beneficios de unirse a ... o responder interesantes

202
00:12:24,483 --> 00:12:29,466
ddatos cuando en realidad estás que no se incorporan en

203
00:12:29,483 --> 00:12:31,466
las llaves primarias, relaciones de llaves foranéas.

204
00:12:31,483 --> 00:12:34,183
>> ¿Cuál es la diferencia entre un INNER JOIN y un OUTER JOIN?

205
00:12:34,483 --> 00:12:39,466
>> El INNER JOIN, se obtiene sólo a través de las combinaciones reales

206
00:12:39,483 --> 00:12:45,233
a través de la tabla o las tablas involucradas, así que lo que puede ver

207
00:12:45,316 --> 00:12:49,466
en ello, lógicamente es, se toman dos tablas y se obtiene el conjunto masivo

208
00:12:49,483 --> 00:12:53,466
de todas las filas combinadas con todas las otras filas, y entonces aplicar

209
00:12:53,483 --> 00:12:55,466
el filtro en la cláusula ON.

210
00:12:56,316 --> 00:12:59,466

Obviamente, si se aplica esto, se dice que este ID es igual al ID,

211
00:12:59,483 --> 00:13:03,466
que sólo devolverá lo filas en realidad están emparejando a través

212
00:13:04,333 --> 00:13:09,466
de estas dos tablas. Entonces, ¿qué si, como un ejemplo que será, bueno, Brian,

213
00:13:09,483 --> 00:13:14,183
por favor, dame todos los clientes y sus pedidos, por lo que probablemente

214
00:13:14,266 --> 00:13:19,466
se hace un JOIN de la tabla clientes a la tabla de ordenes para el ID del cliente.

215
00:13:20,483 --> 00:13:24,433
Si cambio la pregunta un poco, y esta es una buena manera también

216
00:13:24,483 --> 00:13:27,466
de la clase de la práctica de SQL está traduciendo en realidad una pregunta

217
00:13:27,483 --> 00:13:35,166
en Inglés o, preferiblemente, de Suecia, de donde soy, a SQL.

218
00:13:35,250 --> 00:13:38,466
Así que si en lugar de decir, oye, ¿puedes por favor, dame la lista de.

219
00:13:38,483 --> 00:13:42,466
todos los clientes y sus pedidos? y también incluyen a los clientes que

220
00:13:42,483 --> 00:13:46,366
no tienen ninguna orden, porque los que no serán devueltas si uso

221
00:13:46,450 --> 00:13:50,466
este INNER JOIN. Así que el que lo haría en su lugar, si digo de los clientes,

222
00:13:51,300 --> 00:13:56,466
JOIN pedidos, diría LEFT JOIN, por lo LEFT OUTER JOIN, que

223
00:13:56,483 --> 00:14:00,466
es mantener las filas que no se pongan en venta de la tabla de la izquierda, para que

224
00:14:00,483 --> 00:14:03,466
los clientes se dice en primer lugar. Esa sería la tabla de la izquierda, y las ordenes

225
00:14:03,483 --> 00:14:06,466
sería la tabla de la derecha. Así que hemos combinación izquierda, evitar que la

226
00:14:06,483 --> 00:14:08,466
tabla de la izquierda, derecha JOIN es simplemente evitar que el cuadro de la derecha, y

227
00:14:09,333 --> 00:14:12,466
FULL JOIN también se incluyen órdenes que no tienen un cliente coincidentes.

228
00:14:12,483 --> 00:14:15,466
Eso suena como un problema de integridad referencial en este caso,

229
00:14:15,483 --> 00:14:18,466
pero eso es básicamente los OUTER JOINs.

230
00:14:18,483 --> 00:14:22,466
>> Muy bien, excelente. Y este es un ejemplo de cómo un LEFT OUTER

231
00:14:22,200 --> 00:14:26,216
JOIN ya que se acaba de describir se escribiría. Así que estamos buscando

232
00:14:26,300 --> 00:14:28,466
a los clientes que no hacen pedidos en este caso aquí, por lo que esto

233
00:14:28,483 --> 00:14:32,466
es un ejemplo de ese comando que acaba de Tobias en realidad nos explicó

234
00:14:32,483 --> 00:14:34,466
CROSS JOINs.

235
00:14:35,483 --> 00:14:38,400
CROSS JOINs combinar cada rol de la primera tabla con cada

236
00:14:38,483 --> 00:14:40,466
la fila de la segunda tabla. ¿Que nos da eso?

237
00:14:43,483 --> 00:14:46,400
Estamos combinando todas las filas de una tabla a la otra mesa.

238
00:14:46,483 --> 00:14:47,466
¿Por qué debería utilizar un CROSS JOIN?

239
00:14:48,483 --> 00:14:54,366
>> Bueno, no es todo lo que muchas razones. Se podría imaginar ...

240
00:14:54,483 --> 00:15:00,466
así que una cosa es, obviamente, sólo la generación de datos de prueba, es muy

241
00:15:00,216 --> 00:15:02,466
práctico, ya que se toma una tabla con 10 filas, CROSS JOIN

242
00:15:02,483 --> 00:15:06,466
con otra tabla con 10 filas, se obtiene 100 filas más atrás. Pero

243
00:15:06,483 --> 00:15:08,466
en realidad se podría tener un ejemplo interesante, como usted tiene una

244
00:15:09,166 --> 00:15:12,466
tabla de monedas con todas las monedas y CROSS JOIN

245
00:15:12,483 --> 00:15:15,216
que con ella misma, ya que usted consigue el producto de todas las combinaciones

246
00:15:15,300 --> 00:15:16,333
de monedas.

247
00:15:18,483 --> 00:15:22,466
>> Muy bien, así que no se utiliza en gran medida es lo que he oído, pero es bueno

248
00:15:22,483 --> 00:15:23,466
tenerlo por ahí.

249
00:15:24,450 --> 00:15:25,466
Así que ahora tenemos un SELF JOIN.

250
00:15:26,483 --> 00:15:29,200
El SELF JOIN, compara las filas de la misma tabla a la otra.

251
00:15:29,283 --> 00:15:30,466
¿Tengo un ejemplo de esto?.

252
00:15:30,483 --> 00:15:33,466
>> Pues bien, el ejemplo de divisas que di fue un ejemplo de un SELF

253
00:15:33,483 --> 00:15:35,466
JOIN, con un CROSS JOIN.

254
00:15:35,483 --> 00:15:38,466
>> Con un CROSS JOIN. Para que pueda tener SELF JOIN con CROSS JOIN.

255
00:15:38,483 --> 00:15:41,466
>> Si. SELF JOIN es sólo si se usa JOIN con uno mismo.

256
00:15:41,483 --> 00:15:44,466
>> ¿Cuáles son los más utilizados? Yo diría que el INNER

257
00:15:44,166 --> 00:15:46,466
JOIN, porque esa es la forma predeterminada. Si sólo tiene que teclear el JOIN,

258
00:15:46,166 --> 00:15:49,466
se obtiene el INNER, y luego LEFT y RIGHT OUTER JOINs, lo más probable.

259
00:15:49,483 --> 00:15:50,466
>> Si, absolutamente.

260
00:15:50,483 --> 00:15:54,466
>> Entonces, su SELF JOIN y su CROSS JOIN, son opciones,

261
00:15:54,483 --> 00:15:58,466
pero probablemente no se utiliza en gran medida. Tenemos, como se puede ver aquí,

262
00:15:58,483 --> 00:16:02,466
ejemplos disposición para la forma en que se escriben, pero

263
00:16:03,483 --> 00:16:07,466
sólo para la clase de darle algunas ideas sobre cómo iban a ser utilizados.

264
00:16:07,483 --> 00:16:09,466
>> Sí. Es, definitivamente, en el orden del INNER JOINs Y LUEGO LEFT

265
00:16:09,483 --> 00:16:11,466
JOINs y luego FULL JOINs.

266
00:16:11,483 --> 00:16:14,466
>> Vamos a echar un vistazo a algunos de ellos, si podemos conseguir sólo

267
00:16:14,483 --> 00:16:19,466
un par de ellos para ejecutar. Una vez más, he salvado todo el

268
00:16:19,483 --> 00:16:23,466
dolor de cabeza de mí en grasa los dedos y tratando de escribir todo esto.

269
00:16:23,483 --> 00:16:26,466
Se trata de que la declaración que he creado anteriormente, que te mostré

270
00:16:26,483 --> 00:16:27,466
antes, debería decir.

271
00:16:29,483 --> 00:16:33,200
Tratando de conseguir que se deslice hacia abajo. Aquí vamos. Así que este es el

272
00:16:33,283 --> 00:16:36,466
que yo había escrito antes, o se señaló anteriormente, por lo que esto

273
00:16:36,483 --> 00:16:40,466
es muestra de que INNER JOIN, y como Tobias señaló, no hacer

274
00:16:40,483 --> 00:16:43,366
INNER JOIN alli. Yo podría hacerlo un poco más claro

275
00:16:43,450 --> 00:16:47,466
poniéndolo como INNER JOIN, para que pueda ver exactamente el tipo de

276
00:16:47,483 --> 00:16:50,466
JOIN que es, pero es el valor predeterminado. Así que vamos a seguir adelante

277
00:16:50,483 --> 00:16:51,466
y ejecutar este.

278
00:16:52,483 --> 00:16:55,466
And notice we have our SalesOrderID. Remember, that's coming

279
00:16:55,483 --> 00:16:59,466
from the SOH, which is the order header. We have the OrderDate.

280
00:16:59,483 --> 00:17:03,466
That's also coming from the order header table. And then we

281
00:17:03,483 --> 00:17:04,466
have three SOD

282
00:17:05,483 --> 00:17:08,466
columns we'll be returning. These are coming from the SalesOrderDetail,

283
00:17:08,483 --> 00:17:12,466
so ProductID, UnitPrice and OrderQty. These are being returned

284
00:17:13,483 --> 00:17:16,466
from the details. So it's a good way to take content that resides

285
00:17:16,483 --> 00:17:21,383
in two different tables. We JOIN them on SalesOrderID... in this

286
00:17:21,466 --> 00:17:25,466
case here, 43659, and return results from two different tables

287
00:17:25,483 --> 00:17:27,350
into one result set.

288
00:17:28,450 --> 00:17:30,466
So it's good that we're able to do that, because often, when

289
00:17:30,483 --> 00:17:32,466
we're working with relational databases, we're going to have

290
00:17:32,483 --> 00:17:35,383
content multiple tables, and we're going to want to maybe return

291
00:17:35,466 --> 00:17:39,0
that content into a single result set, and the use of JOINs will

292
00:17:39,483 --> 00:17:42,466
help you perform that. Here's one more example we'll do with

293
00:17:42,483 --> 00:17:46,466
a JOIN, and this is the LEFT OUTER JOIN here, and the LEFT OUTER

294
00:17:47,0 --> 00:17:49,466
JOIN is going to return all customers... I just messed that up.

295
00:17:50,483 --> 00:17:53,466
Where's my undo in this thing? Undo saves me. There we go.

296
00:17:56,483 --> 00:17:59,466
So here's an example of a LEFT OUTER JOIN. Again, we saw this

297
00:17:59,483 --> 00:18:04,466
on the slide, but we have CustomerID and StoreID, SalesOrderID

298
00:18:04,483 --> 00:18:08,466
and OrderDate. And you can see here that CUST.StoreID,

299
00:18:10,483 --> 00:18:16,466
these are coming in from the order table, and then the ORD, which

300
00:18:16,483 --> 00:18:20,466
is the SalesOrder header, is the SalesOrderID. So we're grabbing

301
00:18:20,483 --> 00:18:24,466
content from the left table or the first query in the statement

302
00:18:25,483 --> 00:18:29,466
and we're adding additional content from the right statement.

303
00:18:29,166 --> 00:18:33,466
So just a quick example just to show you that those do run and

304
00:18:33,483 --> 00:18:36,433
that when we're displaying them, so just want to show you how

305
00:18:36,483 --> 00:18:40,466
those JOINs actually work for you when we're executing those JOINs.

306
00:18:42,483 --> 00:18:46,466
All right, so those are ways for retrieving content from inside

307
00:18:46,200 --> 00:18:50,466
of SQL Server from different rows or different tables, if you will.

308
00:18:50,483 --> 00:18:54,466
We also have a lot of ways that we want to filter and sort data,

309
00:18:54,483 --> 00:18:58,216
and we use the ORDER BY clause, and I briefly did a demo of this already.

310
00:18:58,300 --> 00:19:00,466
The ORDER BY just sorts the rows,

311
00:19:01,483 --> 00:19:05,466
and it's just a way to make the presentation of the content easier

312
00:19:05,483 --> 00:19:08,466
for you. You want to be able to see SalesOrderID.

313
00:19:09,483 --> 00:19:15,466
We want it in order, and as an integer. Maybe you want customer

314
00:19:15,483 --> 00:19:18,433
by last name, you want to sort them alphabetically. Maybe you

315
00:19:18,483 --> 00:19:21,466
want order date. We want to know the most recent order or the

316
00:19:21,483 --> 00:19:27,466
order that came in in the past. These are examples of ORDER BYs.

317
00:19:27,483 --> 00:19:30,166
So we're doing a SELECT SalesOrderID, CustomerID and OrderDate

318
00:19:30,250 --> 00:19:33,466
from the SalesOrderHeader, and we're going to order it by OrderDate,

319
00:19:33,483 --> 00:19:38,466
so we're going to give us three columns, SalesOrderID, CustomerID

320
00:19:38,483 --> 00:19:41,466
and OrderDate, and we're going to order it chronologically, I

321
00:19:41,483 --> 00:19:44,183
think is the right word, by OrderDate.

322
00:19:44,483 --> 00:19:47,466
We could also go in and do a SELECT SalesOrderID, CustomerID.

323
00:19:47,483 --> 00:19:50,433
Now we're gathering the year, and we're going to create a column,

324
00:19:50,483 --> 00:19:55,416
the YEAR from the OrderDate, AS OrderYear, again from the SalesOrderHeader,

325
00:19:55,483 --> 00:19:59,466
and we're going to ORDER BY OrderYear. This is an alias we created

326
00:19:59,483 --> 00:20:01,466
because we're grabbing just the year from the OrderDate.

327
00:20:01,483 --> 00:20:04,466
We're not worried about the time or the date.

328
00:20:04,483 --> 00:20:07,466
>> So here's there's something that's just worth mentioning that

329
00:20:07,483 --> 00:20:12,466
many people typically ask. So you can say AS OrderYear and then

330
00:20:12,483 --> 00:20:17,466
ORDER BY this alias OrderYear, but you can't do it as OrderYear

331
00:20:17,483 --> 00:20:20,466
and then in the WHERE clause say WHERE OrderYear is equal to

332
00:20:20,483 --> 00:20:23,466
something, and that has to do with this logical query processing

333
00:20:23,483 --> 00:20:26,466
that we talked about earlier, because ORDER BY is the only thing

334
00:20:26,483 --> 00:20:31,416
that happens after SELECT. So when ORDER BY happens, we know

335
00:20:31,483 --> 00:20:34,466
what the column aliases are, but when WHERE happens, we don't

336
00:20:34,483 --> 00:20:36,466
know, because SELECT hasn't happened yet.

337
00:20:36,483 --> 00:20:38,466
>> Great point. Definitely great point. And the cool thing is,

338
00:20:38,483 --> 00:20:40,466
we can reverse this. We've got the same...

339
00:20:42,483 --> 00:20:45,466
the top example here is OrderDate. We could do it in reverse

340
00:20:45,483 --> 00:20:49,466
order just by using the descending clause down here. And that

341
00:20:49,233 --> 00:20:52,466
gives us the same content, but in reverse order of the dates,

342
00:20:53,0 --> 00:20:56,466
so instead of the most recent... or instead of the earliest

343
00:20:56,483 --> 00:21:00,466
one, we'll have the most recent one on top. We filter data using

344
00:21:00,183 --> 00:21:02,466
the WHERE clause. That's one way that we do that. We've seen

345
00:21:02,483 --> 00:21:05,466
an example of that, where we had all the rows being dumped out.

346
00:21:05,483 --> 00:21:08,466
A little bit overwhelming. So what we've got here is we've got

347
00:21:08,483 --> 00:21:12,466
CustomerID, TerritoryID from the Sales.Customer. If I just stop

348
00:21:12,483 --> 00:21:15,466
there and not have a WHERE clause, every row is going to be returned

349
00:21:15,183 --> 00:21:17,466
from the Customers table. Well, we're going to throw WHERE TerritoryID

350
00:21:17,483 --> 00:21:21,433
= 6, so I want to know where all the customers are that belong

351
00:21:21,483 --> 00:21:24,466
in TerritoryID = 6, or I don't have to use equal. I could say

352
00:21:24,483 --> 00:21:29,350
WHERE TerritoryID >= 6. So now I want all the customers in territories

353
00:21:29,433 --> 00:21:32,466
seven through whatever number it goes through. We could also

354
00:21:32,483 --> 00:21:35,266
mix some of these up. In the bottom one, we talk about WHERE

355
00:21:35,350 --> 00:21:37,466
StoreID >= 1000 AND StoreID <= 1200.

356
00:21:40,483 --> 00:21:43,466
So I want everything where the StoreID... now, I've moved away

357
00:21:43,483 --> 00:21:48,466
from the TerritoryID. The StoreID is 1000 or higher, but no higher

358
00:21:48,483 --> 00:21:54,466
than 1200, so we've got that little gap area or range that we

359
00:21:54,483 --> 00:21:57,466
want that StoreID or the content for that StoreID to be returned in.

360
00:21:57,483 --> 00:22:00,466
So again, it's controlling what's happening in a result set and

361
00:22:01,166 --> 00:22:02,466
how that content is being displayed to you.

362
00:22:04,166 --> 00:22:06,466
Other ways we can filter data. Maybe I want more controls.

363
00:22:06,483 --> 00:22:11,466
I don't want to see every item. Maybe I've got 100,000 or 500,000

364
00:22:11,483 --> 00:22:15,466
rows, and I want just a portion of those rows. But what we can

365
00:22:15,483 --> 00:22:20,333
do here is use what's called the SELECT TOP option, and we specify

366
00:22:20,483 --> 00:22:23,466
the number of items that we want to see. If I do this SELECT

367
00:22:23,483 --> 00:22:26,466
SalesOrderID, CustomerID, from the SalesOrderHeader, and did

368
00:22:26,483 --> 00:22:31,466
ORDER BY TotalDue DESC, I could get 20,000 records. I don't know.

369
00:22:31,483 --> 00:22:34,216
But what I'm saying here is just give me the top 20.

370
00:22:34,483 --> 00:22:37,466
So in this SELECT TOP (20), say, I don't what 100,000 records.

371
00:22:37,483 --> 00:22:40,466
I want 20 records or whatever number I put in there, so I could

372
00:22:40,483 --> 00:22:43,416
change that to 50 and get the top 50 records. Now, the thing

373
00:22:43,483 --> 00:22:46,466
with that is, if I have 100,000 or 200,000 records and I'm trying

374
00:22:46,483 --> 00:22:51,466
to do this SELECT TOP (20), what if I had 15 and there's eight

375
00:22:51,483 --> 00:22:55,466
more that match, that are exactly identical. What this will

376
00:22:55,483 --> 00:22:57,466
do is it will SELECT TOP (20) WITH TIES.

377
00:22:58,316 --> 00:23:01,466
Now, instead of displaying just 20, if it hits the 20, if there

378
00:23:01,483 --> 00:23:04,466
happens to be 23 because we have some ties, it's going to show

379
00:23:04,483 --> 00:23:07,466
you 23 items, because it doesn't want to show you 20. Let's say,

380
00:23:07,483 --> 00:23:11,466
for instance, we have a salesperson, and the top 20 salespeople

381
00:23:11,483 --> 00:23:13,466
in sales get a bonus.

382
00:23:13,483 --> 00:23:17,466
Well, if I just did a SELECT TOP (20) and there were 25 people

383
00:23:17,483 --> 00:23:21,300
or 23 people that had the top sales but I didn't put the WITH

384
00:23:21,383 --> 00:23:24,466
TIES, there's three people that are not going to get that bonus.

385
00:23:25,0 --> 00:23:26,466
There's three people that are going to be upset with me and the

386
00:23:26,483 --> 00:23:27,466
way I wrote the code.

387
00:23:28,283 --> 00:23:32,300
So we can be careful about that. We can avoid the information

388
00:23:32,383 --> 00:23:36,466
being ignored or not displayed by using the WITH TIES option.

389
00:23:36,483 --> 00:23:39,466
We could just go a percentage. I have 20,000 rows. Instead of

390
00:23:39,483 --> 00:23:43,466
going a finite number of rows being returned, we could just do

391
00:23:44,166 --> 00:23:47,466
a percentage of items that are returned. So if I have 20,000

392
00:23:47,483 --> 00:23:52,466
items, I'll get 20 items. Don't hold me on the math, so we'll

393
00:23:52,483 --> 00:23:53,466
have to see on that here.

394
00:23:53,483 --> 00:23:57,216
>> So I'll show a bit of a demo I thought on TOP, because TOP

395
00:23:57,300 --> 00:23:58,466
is somewhat interesting.

396
00:23:59,483 --> 00:24:05,466
So if we switch over to my machine here, what I'd like to show

397
00:24:05,483 --> 00:24:09,466
is, first of all, you already saw TOP, right? We also have support

398
00:24:09,483 --> 00:24:14,466
now in SQL Server 2012 for OFFSET and the FETCH keywords, which

399
00:24:14,483 --> 00:24:18,466
helps you page through the results, which is very common in web applications.

400
00:24:18,483 --> 00:24:23,466
So let's say I just go for Production.Product and

401
00:24:24,483 --> 00:24:26,466
then I say ORDER BY,

402
00:24:28,483 --> 00:24:32,466
I don't know, UnitPrice, is it ListPrice? There we go, ListPrice.

403
00:24:32,483 --> 00:24:35,466
Now, this will give me the full result set back. What I can

404
00:24:35,483 --> 00:24:40,466
now go and do is say, well, please OFFSET 10 ROWS

405
00:24:41,483 --> 00:24:43,466
and FETCH

406
00:24:45,483 --> 00:24:47,466
NEXT 10 ROWS ONLY,

407
00:24:49,483 --> 00:24:53,466
and that will actually give me the rows 11 through 20, and now

408
00:24:53,483 --> 00:24:59,466
I can go and say you see the first one here is Chainring, apparently.

409
00:24:59,483 --> 00:25:04,466
If I go and say, well, SKIP 20 ROWS, it's still...

410
00:25:06,483 --> 00:25:08,466
>> Or OFFSET 20 ROWS.

411
00:25:10,483 --> 00:25:11,466
>> Oh, sorry.

412
00:25:11,483 --> 00:25:14,266
Let's see here.

413
00:25:15,483 --> 00:25:18,466
Now there is something. So what's going on here? Well, these

414
00:25:18,483 --> 00:25:23,466
guys all have the same list price, so by accident I showed you

415
00:25:23,483 --> 00:25:25,466
an even better example. This is amazing.

416
00:25:25,483 --> 00:25:26,283
>> Exactly.

417
00:25:26,366 --> 00:25:32,450
>> Oh, how good we are, Brian. This is really good. So here we

418
00:25:32,483 --> 00:25:37,466
see a problem that is common with basically both TOP and OFFSET

419
00:25:37,483 --> 00:25:39,466
and FETCH, which is what happens if I don't order by something

420
00:25:40,0 --> 00:25:44,466
that's unique. So let's go and add ProductID in here, which will

421
00:25:44,483 --> 00:25:46,333
make it make some more sense.

422
00:25:46,483 --> 00:25:50,466
Now, okay, Fork Crown is apparently the top row, and then I'll

423
00:25:50,483 --> 00:25:51,466
go and say, well, 40...

424
00:25:52,483 --> 00:25:56,0
I'm jumping now forward. And you obviously can use variables

425
00:25:56,483 --> 00:26:02,233
and expressions, so I could say here @ OFFSET as I'm passing in.

426
00:26:02,316 --> 00:26:04,466
So that's one thing I wanted to show you guys, which is interesting.

427
00:26:04,483 --> 00:26:08,166
The other thing, which is a bit special and we haven't talked

428
00:26:08,483 --> 00:26:11,466
about UNION, because we don't have it particularly in any of

429
00:26:11,483 --> 00:26:17,466
our slides, but UNION is the combination of result sets by concatenating

430
00:26:17,483 --> 00:26:22,233
them rather than JOIN, which is combining them horizontally.

431
00:26:22,316 --> 00:26:28,466
So I have an example query that let's say Brian just asked me,

432
00:26:28,483 --> 00:26:33,466
hello, Tobias, can I get the two most expensive black products

433
00:26:33,483 --> 00:26:37,466
and the two most expensive red products in a query. And you

434
00:26:37,483 --> 00:26:39,466
go, okay, that sounds like a reasonable question, Brian.

435
00:26:39,483 --> 00:26:40,466
>> For a Lamborghini.

436
00:26:41,483 --> 00:26:45,466
>> Yes, yes. So I'll go, okay, let's get Name and

437
00:26:47,483 --> 00:26:49,466
ListPrice and Color.

438
00:26:50,483 --> 00:26:53,466
It must be a fairly boring product, since the only have one color,

439
00:26:53,483 --> 00:27:00,466
but anyhow. And I probably want top two, right, and then WHERE

440
00:27:00,483 --> 00:27:06,250
Color = "Black" in this case, and I don't know if black is actually

441
00:27:06,333 --> 00:27:11,466
a color and how that works, but at any rate. And obviously ORDER

442
00:27:11,483 --> 00:27:16,233
BY is important here. You say ORDER BY ListPrice DESC, since

443
00:27:16,316 --> 00:27:19,466
we want the most expensive products. Okay, so that happens to

444
00:27:19,483 --> 00:27:21,466
be this Mountain 100 Black.

445
00:27:21,483 --> 00:27:23,466
>> I think it's a mountain bike or something.

446
00:27:24,483 --> 00:27:25,466
>> Well, you never know.

447
00:27:25,483 --> 00:27:26,466
>> Never know.

448
00:27:26,483 --> 00:27:30,466
>> And the I also wanted the red product, so that seemed like

449
00:27:30,183 --> 00:27:35,466
a separate query, so also give me the two most expensive red products.

450
00:27:36,0 --> 00:27:39,466
Okay, there we have those. Now, this UNION clause will be very

451
00:27:39,483 --> 00:27:42,466
interesting, because that's, again, just taking these without

452
00:27:42,483 --> 00:27:47,466
result sets and smashing them together, so I'll say UNION ALL.

453
00:27:47,483 --> 00:27:51,466
UNION is implicitly a DISTINCT, so you will automatically go

454
00:27:51,483 --> 00:27:55,466
and remove duplicates. That's per the standard, and obviously that's...

455
00:27:55,483 --> 00:27:58,466
if you know there are no duplicates between the sets, why pay

456
00:27:58,483 --> 00:28:01,466
the cost doing it, so UNION ALL means don't remove duplicates.

457
00:28:01,483 --> 00:28:04,466
Actually, the SELECT statement, you can say SELECT ALL, means

458
00:28:04,483 --> 00:28:08,466
the same, but no one ever types it. So SELECT DISTINCT and SELECT ALL.

459
00:28:08,483 --> 00:28:11,466
So now, we see there is a red squiggly here, right?

460
00:28:12,483 --> 00:28:16,400
So if I try this, it will start complaining and say, hey, Tobias,

461
00:28:16,483 --> 00:28:21,466
this doesn't really make sense. Because ORDER BY is at the set level.

462
00:28:21,483 --> 00:28:24,466
It's at the result set level, so what we're going to actually return.

463
00:28:25,283 --> 00:28:26,466
So we know...

464
00:28:28,483 --> 00:28:30,466
something happened on my screen.

465
00:28:30,483 --> 00:28:32,466
Well, now

466
00:28:34,483 --> 00:28:35,466
we see me, but not the screen.

467
00:28:35,483 --> 00:28:38,466
>> We're back to you. Should we go back to the demo?

468
00:28:38,483 --> 00:28:40,466
>> So now you can see me typing.

469
00:28:41,216 --> 00:28:44,316
>> Pretend he's typing the keys that you were just looking at.

470
00:28:45,266 --> 00:28:49,466
>> Wonderful. Here we go. So, again, we saw this was the two most

471
00:28:49,483 --> 00:28:54,466
expensive black and these were the two most expensive, so about 3000.

472
00:28:54,483 --> 00:28:57,466
So let's just remove this ORDER BY clause,

473
00:28:59,366 --> 00:29:01,466
and we now get something completely different back. And this

474
00:29:02,483 --> 00:29:06,350
is because of the logical processing of the query, right, because

475
00:29:06,433 --> 00:29:07,466
first we go and do

476
00:29:08,483 --> 00:29:12,466
the FROM clause, the WHERE clause, so we get all of the black

477
00:29:12,483 --> 00:29:17,466
products, and then we get just the top first two that we find.

478
00:29:17,483 --> 00:29:20,466
And then we go and do the same with the red products, the top

479
00:29:20,483 --> 00:29:23,383
first that we find, then we concatenate the result sets and then

480
00:29:23,466 --> 00:29:27,466
we sort the result set. So if you turn on the query execution

481
00:29:27,483 --> 00:29:32,466
plan that we can find up here, this is something also people

482
00:29:32,483 --> 00:29:35,466
use to basically optimize their queries, but it can also be very

483
00:29:35,483 --> 00:29:38,466
useful to actually just understand what's going on. So if I

484
00:29:38,483 --> 00:29:41,466
look at the execution plan here, we can see, we apparently go

485
00:29:41,483 --> 00:29:45,466
and scan an index here, which is the table, the clustered index.

486
00:29:45,483 --> 00:29:47,466
Then we do top immediately.

487
00:29:48,183 --> 00:29:50,466
There's no sorting that happens before that. Then we concatenate

488
00:29:50,483 --> 00:29:54,466
the result sets, and now we go sort based on color.

489
00:29:55,483 --> 00:29:59,466
So what I want to do is, instead of this, which there is no...

490
00:29:59,483 --> 00:30:02,466
it's not a bug in the product, right? It's just the way that

491
00:30:02,483 --> 00:30:06,333
the language works. Instead I can do... and this we will get

492
00:30:06,416 --> 00:30:09,466
into more details on later, but I can do a derive table here

493
00:30:09,483 --> 00:30:12,466
and say, well, FROM this SELECT clause.

494
00:30:13,483 --> 00:30:17,466
Now, it's not ambiguous anymore. I'm saying, well, grab this

495
00:30:17,483 --> 00:30:21,466
result set. Now it's the two most expensive black products, and

496
00:30:21,483 --> 00:30:23,466
then concatenate that with the

497
00:30:25,333 --> 00:30:28,466
two most expensive red products.

498
00:30:28,483 --> 00:30:32,233
We have to have aliases here on the tables here or on these sets.

499
00:30:33,483 --> 00:30:36,416
And now we'll get the right result. And now I can obviously

500
00:30:36,483 --> 00:30:38,466
also add an ORDER BY down here and say, well, I would like to

501
00:30:38,483 --> 00:30:44,183
order by name. So that result set, I want those four rows sorted

502
00:30:44,266 --> 00:30:44,466
by name.

503
00:30:45,483 --> 00:30:48,466
So we get that back, seems to make sense, and now the execution

504
00:30:49,483 --> 00:30:51,466
plan, we can see we have a different operator here, which is

505
00:30:51,483 --> 00:30:54,466
now the top sort operator.

506
00:30:54,483 --> 00:30:57,333
Then we concatenate and then we sort the result set.

507
00:30:57,416 --> 00:30:57,466
>> Nice.

508
00:30:57,483 --> 00:31:02,466
>> So here we can just see, what does UNION do, which can clearly

509
00:31:02,200 --> 00:31:07,466
be useful, and actually how TOP intersects with ORDER BY.

510
00:31:07,483 --> 00:31:09,466
>> All right, excellent. Great demo. All right, so that's going

511
00:31:10,483 --> 00:31:13,466
to wrap up module two here. We talked about the SELECT statement,

512
00:31:13,483 --> 00:31:16,466
we introduced the DISTINCT, reduce. There is some overhead involved,

513
00:31:16,483 --> 00:31:19,466
as Tobias pointed out to us, about the DISTINCT removes those

514
00:31:19,483 --> 00:31:23,466
redundant roles. We introduced both column and table aliases.

515
00:31:23,483 --> 00:31:26,466
We talked about the CASE statement. We talked about the few

516
00:31:26,483 --> 00:31:28,466
different types of JOINs that we are going to be comfortable

517
00:31:28,483 --> 00:31:32,266
or need to get comfortable working with. Specifically, the default

518
00:31:32,350 --> 00:31:36,0
one is the INNER JOIN, and we have the OUTER JOINs. We looked

519
00:31:36,483 --> 00:31:39,350
at the ORDER BY and the WHERE clause. We had a nice demo from

520
00:31:39,433 --> 00:31:43,466
Tobias on the UNION clause, and we also talked about the TOP

521
00:31:43,483 --> 00:31:47,466
clause in this area, here. So let's go ahead and take a 10-minteu

522
00:31:47,483 --> 00:31:50,466
break, and what we do when we come back, when we come back, we're

523
00:31:50,483 --> 00:31:52,466
going to go into the next module.

524
00:31:53,483 --> 00:31:56,466
And when we go to the next module, we're going to start talking

525
00:31:56,483 --> 00:31:59,466
about some additional... again, more advanced topics when we're

526
00:31:59,483 --> 00:32:05,250
looking at ways for us to query content from SQL Server 2012.

